[toc]



## 1.对象存活判断

### 引用计数

- **机制**：每个对象持有一个引用计数器，每当有一个地方引用它时，计数器值加1；引用失效时，计数器值减1。当引用计数为0时，对象可以被回收。
- **问题**：主要问题是无法解决循环引用的问题，因此Java主要采用可达性分析来判断对象的存活。

### 可达性分析

- **机制**：这种方法基于图论，从一系列的根对象（GC Roots）开始向下搜索，如果一个对象到根节点没有任何引用链相连（即从根节点无法到达这个对象），则证明此对象是不可达的。
- **GC Roots**：包括但不限于虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中的类静态属性引用的对象、方法区中常量引用的对象以及本地方法栈中JNI（即通常说的Native方法）引用的对象。





### 对象的引用

在Java中，对对象的引用通常是指指向内存中的对象的指针或句柄。当你在Java程序中创建一个对象时，实际上你在堆内存中创建了对象的实例，并通过引用来操作这个对象。引用存储的是对象在内存中的地址，或者通过某种方式间接指向该地址的信息。

#### 示例

```
Person person = new Person("John Doe");
```

在这个示例中，`person` 是一个引用，它指向 `Person` 类的一个新实例。这个引用存储了实例在内存中的地址，通过这个引用，你可以访问和修改对象的属性或调用对象的方法。





### 引用计数无法解决循环引用的问题

当两个或更多对象相互引用，但没有其他活动引用指向它们时，这些对象理论上是无用的，应该被回收，但由于它们互相持有对方的引用，它们的引用计数永远不会达到零。

示例说明

假设有两个类`A`和`B`，它们互相持有对方的引用：

```
class A {
    B b;
    void linkToB(B b) {
        this.b = b;
    }
}

class B {
    A a;
    void linkToA(A a) {
        this.a = a;
    }
}

public class Main {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();

        a.linkToB(b);  // A对象持有B对象的引用
        b.linkToA(a);  // B对象持有A对象的引用

        a = null;  // 断开外部对A对象的引用
        b = null;  // 断开外部对B对象的引用
    }
}
```

在这个例子中：

- 对象`a`和对象`b`被创建并且互相引用。
- 外部对`a`和`b`的引用被设为`null`，意味着没有外部引用直接指向这两个对象。
- 然而，由于`a`和`b`互相持有对方的引用，它们的引用计数不会降至零。即使它们已经无法从程序的其他部分访问，它们也不会被引用计数的垃圾收集器回收。

此时：尽管`A`和`B`对象内部相互持有对方的引用，它们从程序的外部来看是不可达的，因为没有任何活跃的引用链从根集（如本地变量、静态字段等）指向这两个对象。这种情况下，对象`a`和`b`形成了一个封闭的循环引用，它们在逻辑上已经是不可达的，因为不存在从程序的活跃部分到这个循环的路径。





### 可达性分析（Reachability Analysis）

1. 可达性分析（Reachability Analysis）的核心思想是，如果一个对象可以从任何一个GC Roots开始通过一系列的引用链被访问到，那么这个对象是存活的；否则，对象不可达，可以被视为垃圾收集的候选。

   ### 引用链和GC Roots

   引用链是指从GC Roots开始，每个节点通过字段引用到其他对象的链条。如果至少存在一条这样的链条可以连到某个对象，这个对象就是可达的。

   GC Roots主要包括：

   - 局部变量：所有的本地变量都是GC Roots，这些变量在Java方法的栈帧中，即虚拟机栈中。
   - 活跃的线程：活动线程也是GC Roots，因为它们持有对栈帧中局部变量和参数的引用。
   - 静态字段：由类的定义持有的字段，因为它们属于Java类，而Java类由类加载器加载，存活在方法区中。
   - JNI引用：由本地代码创建并通过JNI接口到Java对象的引用。

   ### 详细的例子解释可达性分析

   假设我们有如下的对象和引用结构，用以解释可达性分析的过程：

   ```
   public class Main {
       private static Main s; // 静态变量，GC Root
       private Main other;    // 实例变量
   
       public static void main(String[] args) {
           Main a = new Main();  // 局部变量，GC Root
           Main b = new Main();  // 局部变量，GC Root
           Main c = new Main();  // 局部变量，GC Root
   
           a.other = b;  // a 引用 b
           b.other = c;  // b 引用 c
           c.other = a;  // c 引用 a 形成一个环
   
           s = a;        // 将 a 保存为静态变量
   
           b = null;     // 断开 b 的引用
           c = null;     // 断开 c 的引用
   
           // 触发垃圾收集
           System.gc();
       }
   }
   ```

   在这个例子中：

   - 对象 `a`、`b`、`c` 在 `main` 方法中创建，并且它们相互引用形成一个环状结构。
   - `a` 被一个静态变量 `s` 引用，并且 `a` 作为局部变量直接位于GC Roots。
   - 当局部变量 `b` 和 `c` 被设置为 `null`，直接从GC Roots到 `b` 和 `c` 的引用路径消失。但由于 `a` 通过静态变量 `s` 依然可达，因此整个环（`a`、`b`、`c`）都仍然可达。

   #### 可达性分析的结果

   - 即使 `b` 和 `c` 的直接引用被删除，它们仍然可以通过 `a` 间接访问。
   - 由于整个环形结构可以通过GC Roots（在这个案例中是静态变量 `s` 和局部变量 `a`）访问到，因此 `a`、`b` 和 `c` 在垃圾收集发生时不会被回收。

   这个例子说明了即使存在复杂的引用环，只要从GC Roots到任意一个对象存在至少一条路径，那么这个对象及其关联的对象都不会被判定为垃圾。



### 补充：这里的b = null是什么意思？意思是：b这个局部变量被清除掉了？

在Java中，当你将一个变量（如 `b`）赋值为 `null`，这意味着你在断开这个变量与它原先指向的对象之间的引用关系。此操作并不是清除 `b` 这个局部变量本身，而是让 `b` 不再指向任何对象。



### 示例解释

考虑如下简化的例子：

```
javaCopy codeMain b = new Main();  // b 指向一个新创建的 Main 对象
b = null;            // 断开 b 和 Main 对象之间的引用
```

在这个例子中：

- **第一行**，`b` 被初始化，指向一个新创建的 `Main` 类的实例。这时，堆内存中存在一个 `Main` 对象，而变量 `b` 存储了指向这个对象的引用。
- **第二行**，将 `b` 赋值为 `null` 后，`b` 不再指向之前创建的 `Main` 对象。如果没有其他引用指向这个 `Main` 对象，那么该对象变成了无法通过任何引用访问的状态，因此成为了垃圾收集的候选对象。



我懂了，Main b = new Main()，分为两步，第一步是在堆上创建一个Main对象，第二步是将b进行解析，链接到这个对象上。将其置为null，表示断开链接，而Main对象此时还并未死亡，直到被判定为不存活，进行垃圾回收





## 2. 垃圾收集算法

### 1. 标记-清除算法 (Mark-Sweep)

**原理**：此算法分为两个阶段，标记和清除。首先，垃圾收集器从根集合开始遍历，标记所有可达的对象。在标记阶段之后，收集器遍历堆，清除所有未被标记的对象。

**优点**：

- 简单直接。
- 不需要额外的空间来进行垃圾回收。

**缺点**：

- 速度可能较慢，因为需要标记所有活动的对象然后清除所有非活动的对象。
- 会产生内存碎片。内存碎片会使得程序在未来分配大对象时可能因为找不到连续的空间而不得不触发更多的垃圾回收。

### 2. 复制算法 (Copying)

**原理**：将内存划分为两块，每次只用其中一块。当这一块内存用完时，程序就将活动的对象（也是通过标记确定对象是否活跃）复制到另一块内存中，并清理掉使用过的内存块。

**优点**：

- 实现简单，回收效率高。
- 解决了内存碎片的问题。

**缺点**：

- 只能使用堆内存的一半，降低了内存的使用效率。
- 对于生命周期较长的对象，频繁复制会降低效率。

### 3. 标记-整理算法 (Mark-Compact)

**原理**：结合了标记-清除和复制算法的优点。首先标记所有可达的对象，然后将所有存活的对象移向内存的一端，接着清理掉边界以外的内存。

**优点**：

- 避免了内存碎片的产生。
- 不需要额外的空间，与复制算法相比，可以利用全部的堆空间。

**缺点**：

- 比复制算法更复杂，移动对象需要更新所有指向这些对象的引用，可能会有更高的开销。



尽管复制算法和标记-整理算法都涉及到“标记”活动对象，但它们的关键区别在于：

- **复制算法**：活动对象被复制到一个新的、干净的内存区域，原区域被完全清空。
- **标记-整理算法**：活动对象在同一内存区域内被移动，以减少碎片，清理未使用的内存。

同时，标记整理是在标记清除的基础上添加了一个整理的步骤，整理过程保证了所有存活对象都紧密地排列在一起，之后的空闲内存都是连续的一块区域，因此解决了内存碎片的问题。



### 4. 分代收集算法 (Generational Collection)

“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。





## 3.垃圾收集器

### CMS (Concurrent Mark Sweep) 收集器

**目标和特点**：

- CMS收集器的主要目标是最小化应用的停顿时间，尤其适用于那些对响应时间敏感的服务端应用。
- 它主要基于“标记-清除”算法实现，通过并发地标记和清除来减少停顿时间。

**工作过程**：

1. **初始标记**（STW短暂停顿）：快速标记所有直接与GC Roots相连的对象。
2. **并发标记**：遍历从GC Roots开始的对象图，标记所有可达的对象，这一过程与应用线程并发执行。
3. **重新标记**（STW短暂停顿）：修正在并发标记期间因应用程序运行所导致的任何变化。
4. **并发清除**：清理未被标记的对象，这一过程也是与应用线程并发执行。

**优点**：

- 最小化停顿时间，提高响应性。

**缺点**：

- 由于采用标记-清除算法，可能会产生较多的内存碎片。
- 在处理老年代时，如果并发模式失败，将触发一次全面的垃圾回收（Full GC），可能导致较长时间的停顿。

### G1 (Garbage-First) 收集器

**目标和特点**：

- G1收集器设计目标是提供一个更可预测的停顿时间模型，适用于大内存应用，并通过划分多个内存区域（Region）来管理整个Java堆。
- G1收集器基于标记-整理算法实现，可以在保持高效率的同时，避免较大的内存碎片。

**工作过程**：

1. **初始标记**（STW短暂停顿）：标记从GC Roots直接可达的对象。
2. **并发标记**：遍历对象图，标记所有可达的对象，过程与应用线程并发。
3. **最终标记**（STW短暂停顿）：处理并发标记阶段遗留下的小部分标记任务。
4. **筛选回收**：根据每个区域的垃圾比例和总的回收优先级来回收那些最有回收价值的区域。

**优点**：

- 可以更精细地控制哪些部分的堆被收集，从而更好地管理停顿时间。
- 通过整理空闲空间，减少内存碎片，优化了内存分配。

**比较CMS和G1**：

- **停顿时间控制**：CMS致力于减少停顿时间，但在高负载或内存碎片严重时可能不稳定。G1提供更可预测的停顿时间。
- **内存管理**：CMS可能导致内存碎片，而G1通过其标记-整理机制有效管理内存碎片，尤其适合大堆内存。



## 4.内存模型和回收策略

![img](https://camo.githubusercontent.com/ee801f1facbe41be0b4c871a7a64df524f6863a0faf104892c06213884c3d420/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f706e672f71647a5a42453733685773626866416e67396962716663626a72716779525771414b69614a32553735534759775168733274754e62587475384b4970615573424f6148524b58663765737575466f4d6a454c467869624956672f3634303f77785f666d743d706e672674703d7765627026777866726f6d3d352677785f6c617a793d312677785f636f3d31)

### Java 堆内存结构

#### 1. 新生代 (Young Generation)

新生代是大多数Java对象诞生并初步存活的地方。新生代主要由三个部分组成：

- **Eden区**：大部分新创建的对象首先在Eden区分配。Eden区通常较大，因为这里频繁地创建和销毁对象。
- **Survivor区**：包括两个部分，From和To。这两个区域的角色会在每次垃圾回收后互换。对象从Eden区存活下来后，首先被移动到From区，随后在连续几次垃圾回收过程中，在From和To区之间移动。只有经常存活的对象最终会被移动到老年代。

#### 2. 老年代 (Old Generation)

老年代用于存放长时间存活的对象。一般来说，这些对象已经经历了多次新生代的垃圾回收，仍然存活的对象会被晋升到老年代中。老年代的大小和生命周期管理是性能调优的重要方面，因为老年代满了会触发Major GC，这通常比Minor GC更耗时。

### 垃圾回收策略

#### Minor GC

- **触发时机**：当Eden区满了时触发。
- **过程**：回收Eden和一个Survivor区（From），将存活的对象移动到另一个Survivor区（To）或直接晋升到老年代。
- **特点**：只涉及新生代，速度较快，频繁发生。

#### Major GC / Full GC

- **触发时机**：老年代满了或其他情况（如System.gc()调用）时触发。
- **过程**：涉及整个堆（包括新生代和老年代），使用标记-清除或标记-整理算法。
- **特点**：STW时间较长，影响性能，尽量避免频繁发生。