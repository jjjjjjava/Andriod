[toc]



## 1.JVM

核心：一次编写，到处执行。

### 1.1困惑：

我不是很理解，我们说，不管任何程序，最终要执行，都是要变成对应平台的cpu可以识别的形式，

我们来考量一个c程序，其最终会经过编译过程，最终成为对应平台可以识别的二进制机器码。

JAVA程序如果最终要执行，也是要变成这个二进制机器码的，除非JAVA内部实现了一个类似小型的编译器，可以在执行过程中识别平台的类型，然后将JAVA编译形成的中间形式翻译为对应的机器码。

### 1.2JVM的执行过程（简化版）

1. **编译阶段**：首先，Java源代码（.java 文件）通过Java编译器被编译成字节码（.class 文件）。这个字节码是一种中间形式，它与平台无关，即不针对任何特定的操作系统或硬件。
2. **加载阶段**：当Java程序运行时，JVM首先通过类加载器将这些字节码加载到运行环境中。
3. **执行阶段**：
   - **解释执行**：JVM内的解释器可以直接解释执行这些字节码。这意味着JVM一边读取字节码，一边将其翻译成可以在特定平台上运行的机器码，并立即执行。
   - **即时编译（JIT）**：为了提高效率，JVM内的即时编译器在程序运行时将经常执行的字节码部分（称为热点代码）编译成特定平台的本地机器码。这样，这些代码在后续执行时不需要再次被解释，而是直接运行本地机器码，大大提高了执行速度。

## 2.JVM工作过程

1. **编译源代码**：
   - Java源文件（`.java`文件）被Java编译器（如`javac`）编译成字节码（`.class`文件）。这些字节码是平台无关的中间代码，可以在任何安装了JVM的系统上运行。
2. **类加载**：
   - **加载**：这是类加载过程的第一步，Java类被读入JVM中。在这个阶段，类加载器从`.class`文件中读取二进制数据，并生成对应的类对象。
   - **链接**：加载完成后，进行链接步骤，链接步骤又分为验证、准备和解析三个子步骤：
     - **验证**：确保被加载的类符合Java语言的规范，并且不会造成安全问题。
     - **准备**：为类的静态变量分配内存，并将其初始化为默认值。
     - **解析**：把类中的符号引用转换成直接引用。
   - **初始化**：这是类加载的最后一个阶段。在这个阶段，JVM根据程序员的意图（在类中定义的静态代码块和静态字段初始化）设置类变量的初始值
3. **执行**：
   - **解释执行**：初始阶段，JVM的解释器逐条解释执行字节码，这提供了最大程度的跨平台兼容性，但性能较慢。
   - **即时编译**：JVM中的即时编译器（JIT）在程序运行时将频繁执行的字节码编译成特定平台的机器码，以提高执行效率。一旦字节码被JIT编译，它将直接执行本地机器码，而不再通过解释器。
4. **运行时优化**：
   - JVM在运行时可以进行多种优化，包括内联、死代码删除和循环展开等，这些都是为了提升程序执行的性能。
5. **垃圾回收**：
   - JVM负责管理程序使用的内存。当对象不再被使用时，JVM的垃圾回收器会自动释放这些对象占用的内存，以防止内存泄漏。



### 2.1类加载器种类

类加载器通常分为启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）。

我不理解啊，这些是什么鬼啊？



1. **启动类加载器（Bootstrap ClassLoader）**：负责加载Java的核心API，这些都是JDK自带的、最基本的类库，对于任何Java应用都是必需的。
2. **扩展类加载器（Extension ClassLoader）**：用于加载Java的扩展库，这些库通常不是编写Java应用时必需的，但提供了一些有用的附加功能，比如加密、各种网络协议支持等。
3. **应用程序类加载器（Application ClassLoader）**：这是直接与我们编写的Java应用交互最多的类加载器。它负责加载我们自己的代码以及添加到项目中的第三方库。



这好像内核啊，内核的核心子系统，然后动态加载的驱动，最后是我们要去处理的应用程序代码。



### 2.2 类加载	

我不是很理解，这个类加载的概念，不应该是.class字节码加载吗？为什么说是类加载呢？c程序加载也是说程序加载啊，类只是程序的一部分啊。

我的解释是：面向对象，这很合理。



### 2.3 **准备**阶段

**准备**：为类的静态变量分配内存，并将其初始化为默认值。

举例：

```
public class Example {
    public static int number;
    public static String text;
    private static final double PI = 3.14159;
}
```

在这个例子中，以下是在**准备**阶段所发生的事情：

1. **为`number`分配内存**：这个静态整数字段被自动初始化为`0`，这是int类型的默认值。
2. **为`text`分配内存**：这个静态字符串字段被初始化为`null`，因为它是一个对象引用。
3. **为`PI`分配内存**：即使`PI`是一个`static final`字段，其在准备阶段也会被设置为`double`类型的默认值`0.0`。然而，在后续的初始化阶段，它将被初始化为`3.14159`。

### 2.4 解析

把类中的符号引用转换成直接引用。

假设我们有两个Java类，`Person` 类和使用它的 `Main` 类：

```
javaCopy codepublic class Person {
    public String name;

    public void sayHello() {
        System.out.println("Hello, " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        p.name = "Alice";
        p.sayHello();
    }
}
```

Main类中对Person类引用，创建了Person对象，访问name字段，调用sayhello方法。这些其实是符号引用。然后在解析阶段，其最终会被替换为Person对象的内存地址，name字段的内存地址，sayhello方法的内存地址。

也就是说从符号引用替换为直接引用。其根本目的就是找到对应的地址，这个替换是借助符号表实现的，符号表保持符合和地址的映射关系。

### 2.5 初始化

初始化阶段其实就是准备阶段的继续，在这个阶段，会将有值的静态变量赋值，然后去执行静态的代码块（如果有的话），注意代码块和方法的区别。

#### 举例说明

假设我们有以下Java类：

```
javaCopy codepublic class InitializationExample {
    static int counter = 5; // 静态变量初始化
    static final int FINAL_VALUE = computeFinalValue(); // 静态方法计算初始值

    static {
        System.out.println("Static block: Setting counter to 10");
        counter = 10; // 静态代码块中修改counter值
    }

    static int computeFinalValue() {
        System.out.println("Computing final value");
        return 20;
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println("Counter value: " + InitializationExample.counter);
        System.out.println("Final value: " + InitializationExample.FINAL_VALUE);
    }
}
```

#### 执行过程

当`Main`类的`main`方法首次访问`InitializationExample`的静态变量`counter`时，`InitializationExample`类将被加载并初始化：

1. **加载**：JVM加载`InitializationExample`类。
2. **验证**：验证字节码等。
3. **准备**：为静态变量分配内存，初始化为默认值（如`counter`被设置为`0`，`FINAL_VALUE`为`0`）。
4. **解析**：解析符号引用到直接引用（如果已进行）。
5. 初始化
   - `counter`被初始化为`5`。
   - `computeFinalValue()`方法被调用，输出"Computing final value"，并返回`20`，`FINAL_VALUE`被设置为`20`。
   - 静态代码块执行，输出"Static block: Setting counter to 10"，并将`counter`更新为`10`。

#### 输出结果

```
Computing final value
Static block: Setting counter to 10
Counter value: 10
Final value: 20
```

### 2.6 运行时优化

JVM在运行时可以进行多种优化，包括内联、死代码删除和循环展开等，这些都是为了提升程序执行的性能。 

#### 1. 方法内联（Method Inlining）

方法内联是一种常用的优化技术，其目的是减少方法调用的开销。在这种优化中，

在这种优化中，如果一个方法体比较小，JVM的即时编译器（JIT）会将这个方法的代码直接插入到调用它的位置，而不是实际进行方法调用。这样做可以避免方法调用过程中的一些额外开销，如栈帧的创建和销毁。

**举例**：

```
javaCopy codeclass Example {
    int add(int a, int b) {
        return a + b;
    }

    void main() {
        int result = add(10, 20);
    }
}
```

在这个例子中，`add`方法可能会被内联，所以在`main`方法中调用`add`时，JIT编译器可能直接用`return 10 + 20;`来替换`add(10, 20);`的调用，从而减少一次方法调用的开销。

#### 2. 死代码删除（Dead Code Elimination, DCE）

死代码删除是指JVM在运行时或编译时识别并移除那些永远不会被执行的代码段。这不仅减少了执行时间，还可以减少程序占用的内存空间。

**举例**：

```
javaCopy codepublic void exampleMethod() {
    if (false) {
        // 这段代码永远不会执行
        doSomething();
    }
}
```

在这里，`if (false)`块内的代码在编译时就可以被识别为不可达代码，并因此被删除。

#### 3. 循环展开（Loop Unrolling）

循环展开是另一种常见的优化技术，它通过减少循环的迭代次数来减小循环控制的开销，通常通过增加每个循环迭代中的操作数量来实现。

**举例**：

```
javaCopy codefor (int i = 0; i < 8; i++) {
    array[i] = i * 2;
}
```

在循环展开后，这个循环可能被转换为：

```
javaCopy codearray[0] = 0 * 2;
array[1] = 1 * 2;
array[2] = 2 * 2;
array[3] = 3 * 2;
array[4] = 4 * 2;
array[5] = 5 * 2;
array[6] = 6 * 2;
array[7] = 7 * 2;
```

这样做可以完全消除循环的开销，但会增加代码的大小。通常只有在循环体小且迭代次数固定时，循环展开才是有效的。

### 2.7 垃圾回收的原理

JVM负责管理程序使用的内存。当对象不再被使用时，JVM的垃圾回收器会自动释放这些对象占用的内存，以防止内存泄漏。

假设一个Java应用创建了如下对象：

```
javaCopy codepublic class Main {
    public static void main(String[] args) {
        Object a = new Object();
        Object b = new Object();
        Object c = new Object();
        a = null; // 'a' 不再引用之前创建的对象
        b = new Object(); // 'b' 现在引用一个新的对象，之前的对象失去引用
        // 'c' 依然保持对其对象的引用
    }
}
```

在上面的示例中：

- 对象`a`最初引用的内存现在不再被任何变量引用。
- 对象`b`最初引用的内存也失去了引用，因为`b`被重新赋值引用了一个新的对象。
- 对象`c`引用的内存仍然被变量`c`持有，因此是可达的。



## 3. 总结

1. 思想ok，接下来我说出我对JVM执行流程的理解：JVM的核心是一次编译，到处执行。因此其会先将代码编译成一个字节码形式的中间文件，然后在实际硬件平台上运行时，会通过解释，将其转化为匹配的机器码。在这个过程中会使用JIT进行缓存常用的字节码为本地机器码，以提高解释效率。      



2. 接下来是真正的过程：

其首先进行编译，将.java文件编译成.class字节码类型中间文件。

然后是类加载过程。

​	首先是加载，分为三种不同的加载器，启动类加载器，扩展类加载器，应用程序类加载器。启动类加载器用于加载java核心类，这些是所有java程序都需要的最基础的组件。然后是拓展类加载器，加载java扩展的类，如：java加密库，这是java按需提供的拓展库。最后是应用程序类加载器，用于加载我们自己编写的项目类。（这好像内核啊，内核的核心子系统，然后动态加载的驱动，最后是我们要去处理的应用程序代码。）

​	接着是链接过程，

​		首先是验证，验证编写的java代码符合规范。

​		然后是准备阶段，为静态变量分配空间并初始化为默认值，即使你里面有赋值，但是在这一阶段都是初始化为0的。初始化阶段才会赋值

​		然后是解析，本质就是从符号引用转化为直接引用，比如我有一个main类，引用了person类，创建person对象，访问name成员，使用getage方法。这些都会被转化为其实际对应的内存地址，这是通过查询符号表实现的，符号表会维护符号和地址的映射关系。 

​	接下来是初始化，在这个阶段，会对静态变量按照程序员在代码中指定的值进行初始化。同时调用静态代码块。

接着是执行阶段，这里面会解释对应的字节码为实际的机器码，然后通过JIT缓存常用的字节码为本地机器码，以提高解释效率。

同时也会进行解释的优化，如：删除死代码，进行内联的展开，进行循环的展开。

最后是内存的回收，当对象不再使用时，会自动回收其占用的内存。



