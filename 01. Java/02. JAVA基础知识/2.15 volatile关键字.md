[toc]

## 1. Volatile

其作用如下：

### 1. **确保可见性**

当一个变量被声明为`volatile`后，它会确保修改的值立即被更新到主存中，同时每次使用前都从主存中刷新。这就意味着不同的线程总是看到这个变量的最新值，无需担心缓存中该变量的副本与主存中的值不同步的问题。

#### 举例说明：

假设有两个线程，线程A和线程B，它们都访问同一个非`volatile`变量`flag`。线程A修改了`flag`的值，但这个新值可能由于优化被暂时存储在A的线程局部缓存中，而不是写回主存。如果此时线程B去读取`flag`变量，它可能读到的是旧值，因为线程B的缓存中还没有更新。

但如果`flag`被声明为`volatile`，那么线程A更新`flag`后的值会立即写回主存，当线程B去读取`flag`时，它会直接从主存读取，从而看到线程A对`flag`最新的修改。

### 2. **防止指令重排序**

在Java内存模型中，编译器和处理器为了优化程序性能，可能会对操作顺序进行重排序。`volatile`变量可以部分地防止指令重排，确保在写`volatile`变量之前的操作不会被编译器重排序到写操作之后。

#### 举例说明：

考虑下面的代码片段：

```
javaCopy codeint x = 0;  // 普通变量
volatile boolean v = false;  // volatile变量

// 线程1
x = 42;
v = true;

// 线程2
if (v == true) {
    // 这里x会是多少？
    use(x);
}
```

如果`v`不是`volatile`的，那么编译器可能会重新排序线程1中的赋值操作，使得`v = true`的赋值先于`x = 42`发生，这样线程2中可能会读到`x`的值是0。但由于`v`是`volatile`的，它保证了`x = 42`在`v = true`之前对所有线程可见（即不会重排序这两条指令），因此线程2看到`v == true`时，可以确保`x == 42`。