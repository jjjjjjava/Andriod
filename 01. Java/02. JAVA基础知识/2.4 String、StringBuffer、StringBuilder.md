[toc]

## 1.介绍

### `String`

`String`类在Java中用来表示不可变的字符序列。这意味着一旦一个`String`对象被创建，它所包含的字符序列就不能被改变。任何看似修改`String`值的操作，实际上都是创建了一个新的`String`对象。

- **不可变性**：这种不可变性有几个优点，包括线程安全和安全性（不可变的数据意味着它不能被外部代码改变），以及在哈希表中作为键的可靠性（不会改变的哈希码）。
- **内存优化**：JVM通过字符串池（String Pool）来优化相同字符串的存储。如果字符串已经存在于池中，则新的引用指向已存在的字符串，不会创建新对象。

### `StringBuffer`

`StringBuffer`提供了一个可变的字符串序列，这意味着您可以在不创建新对象的情况下修改字符串内容。`StringBuffer`是线程安全的，它的大多数方法都是通过同步（通常是通过`synchronized`关键字实现）来确保多线程环境下的操作安全。

- **线程安全**：适合在多线程环境中使用，当字符串内容需要在多个线程间共享并修改时。
- **性能成本**：线程安全特性使得`StringBuffer`在单线程环境下性能不如`StringBuilder`。

### `StringBuilder`

`StringBuilder`与`StringBuffer`非常相似，因为它们都继承自相同的抽象父类`AbstractStringBuilder`，提供了几乎相同的API。然而，`StringBuilder`没有实现线程安全特性，这使得它在单线程环境下运行得更快。

- **非线程安全**：在不需要考虑线程安全的情况下，`StringBuilder`是更好的选择，因为它避免了`synchronized`带来的性能开销。
- **更高效**：适用于字符串的快速构建和修改，特别是在字符串内容在构建过程中频繁变动的场景。

### 使用场景

- **`String`**：适用于字符串值不需要修改的场景，或者在使用字符串作为字典的键或其他需要保证不变性的场合。
- **`StringBuffer`**：适用于需要在多线程环境中修改字符串内容的场景。
- **`StringBuilder`**：适用于单线程中需要修改字符串内容的场景，或者性能要求较高且字符串内部状态频繁变化的情况。

总之，选择使用`String`、`StringBuffer`或`StringBuilder`取决于字符串操作的具体需求，包括是否需要线程安全、性能考虑以及字符串的可变性。理解这些类的不同特性可以帮助您在合适的场景中做出最佳选择。如果您还有其他问题或需要进一步的讨论，请随时提问！



### 总结：

字符串不可变，那就用string。可变，但是要求线程安全，就stringbuffer。可变，但是单线程，要求效率，就stringbuilder。 



#### `String` 的存储

- **字符串池（String Pool）**：`String` 类的特别之处在于，它利用了一个称为字符串池的机制，这个池位于Java堆内存中。当您使用字面量（如 `String s = "hello";`）创建字符串时，JVM 首先检查字符串池中是否已存在字面值相同的字符串。如果存在，就返回对该字符串的引用；如果不存在，就在池中创建一个新的字符串然后返回其引用。这种机制有助于节省内存，因为它减少了相同内容字符串的重复存储。
- **堆存储**：当使用`new String("hello")`这样的表达式时，虽然字符串池仍会被检查（或者更新），但`new`关键字确保每次都会创建一个新的字符串对象在堆上，不管池中是否已存在相同内容的字符串。

#### `StringBuffer` 和 `StringBuilder` 的存储

- **堆内存**：与使用`new`操作符创建的任何其他对象一样，`StringBuffer`和`StringBuilder`对象都存储在堆内存中。这两个类的对象不使用字符串池，每个实例都是独立分配在堆上的。它们的内容可以修改，与`String`对象不同，`StringBuffer`和`StringBuilder`不需要为了修改字符串而创建新的对象。



同时：字符串池通常被认为是存放在老年代中，因为它包含被多个部分共享且生命周期较长的对象。然而，这并不意味着所有`String`对象一开始都在老年代中分配；它们可能首先在新生代中创建，随后根据GC的行为（如晋升）移动到老年代。





## 2.string s = "hello"和string s = new String("hello")的区别

### `String` 对象的创建

当您使用 `new String("hello")` 的方式创建字符串时，实际发生了两件事：

1. **字面量“hello”**：首先，字符串字面量 "hello" 会被检查是否已存在于字符串池中。如果不存在，它会被添加到字符串池中。这个过程只涉及字符串池，与使用 `new` 关键字创建的 `String` 对象无关。
2. **`new String("hello")`**：其次，通过 `new` 关键字显式创建的 `String` 对象是在堆上生成的一个新的 `String` 实例。这个新的对象包含一个指向字符串池中“hello”对象的引用。因此，即使池中已有“hello”，`new String("hello")` 也会在堆上创建一个新的对象，这个对象有自己的内存地址。

### 内存分配

- 字符串字面量（如 `"hello"`）直接引用字符串池中的对象。
- 使用 `new String("...")` 创建的字符串是在堆上新创建的对象，它拥有独立的地址空间。



我懂你意思了，其实就是它是分为两步，首先创建一个新的字符串常量：hello。其次是创建一个string对象，这个对象有对字符串常量的引用。