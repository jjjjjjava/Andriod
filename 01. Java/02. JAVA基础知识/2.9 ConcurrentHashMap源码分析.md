[toc]



## ConcurrentHashMap.java

```
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null,
                            new Node<K,V>(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh >= 0) {
                        binCount = 1;
                        ···
                    }
                    else if (f instanceof TreeBin) {
                       ···
                    }
                    else if (f instanceof ReservationNode)
                        throw new IllegalStateException("Recursive update");
                }
            }
            ···
    }
    addCount(1L, binCount);
    return null;
}
```

#### 代码解析

1. **检查键或值是否为空**：

   ```
   if (key == null || value == null) throw new NullPointerException();
   ```

   `ConcurrentHashMap` 不允许键或值为 null。抛一个空指针异常

2. **计算哈希值**：

   ```
   int hash = spread(key.hashCode());
   ```

   `spread` 方法使用高位扩展算法增强哈希值的位散列性，以减少冲突。

3. **循环直到成功插入**：

   ```
   for (Node<K,V>[] tab = table;;) {
   ```

   使用自旋锁，重试直到成功插入或更新节点。

4. **初始化表或定位桶位**：

   ```
   if (tab == null || (n = tab.length) == 0)
       tab = initTable();
   else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
       if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
           break;
   }
   ```

   如果表未初始化，则初始化表。如果计算出的桶位置为空，使用 `casTabAt` 尝试原子地插入节点，如果成功则跳出循环。

5. **处理桶内节点冲突和迁移**：

   ```
   else if ((fh = f.hash) == MOVED)
       tab = helpTransfer(tab, f);
   else {
       synchronized (f) {
           if (tabAt(tab, i) == f) {
               if (fh >= 0) {
                   binCount = 1;
                   // 链表逻辑
               }
               else if (f instanceof TreeBin) {
                   // 红黑树逻辑
               }
               else if (f instanceof ReservationNode)
                   throw new IllegalStateException("Recursive update");
           }
       }
   }
   ```

   如果桶的首节点哈希值为 `MOVED`，则帮助迁移表。否则，对首节点进行加锁，然后根据节点类型（链表或红黑树）处理插入或更新。

6. **增加计数器**：

   ```
   addCount(1L, binCount);
   ```

   更新 `ConcurrentHashMap` 的大小计数器。

#### 关键点

- **无锁插入**：在遇到空桶位时尝试使用无锁的方式插入，使用 `casTabAt`（Compare-And-Swap）。
- **锁的使用**：仅在需要处理哈希冲突时对当前节点加锁，而不是对整个结构加锁。
- **桶迁移**：在扩容时，桶的首节点会标记为 `MOVED`，任何访问这个桶的操作都必须帮助迁移。

这种设计使得 `ConcurrentHashMap` 在并发环境下可以高效地进行读写操作，同时尽量减少锁的使用，从而提高性能。





## 2. spread

`spread` 方法的目的是优化哈希值，以确保它们在哈希表的不同桶（buckets）之间尽可能均匀地分布。这种均匀分布是通过一个高位扩展算法实现的，这有助于减少哈希冲突，并提高哈希表的整体性能。

其实，本质就是高位和低位杂糅，降低哈希冲突

### `spread` 方法的原理

`ConcurrentHashMap` 使用的 `spread` 方法通常包括以下几个步骤来处理哈希值：

1. **取原始哈希值**：
   - 使用 `key.hashCode()` 方法获得原始哈希值。
2. **高位参与运算**：
   - 将哈希值与其自身右移若干位后的值进行按位异或（XOR）操作。这个步骤的目的是将原始哈希值的高位信息也加入到低位，从而增强哈希值的随机性和均匀分布特性。

举个例子来说明：

假设某个对象的 `hashCode()` 方法返回的哈希值是 `0x12345678`。在 Java 中，`spread` 方法可能会这样实现：

```
static final int HASH_BITS = 0x7fffffff; // 可以忽略符号位

static final int spread(int h) {
    return (h ^ (h >>> 16)) & HASH_BITS;
}
```

这里的 `h >>> 16` 是将 `h` 右移 16 位。这样做的效果是将哈希值的高16位和低16位进行异或操作。假设 `h` 为 `0x12345678`：

- 原始哈希值 `h`: `0001 0010 0011 0100 0101 0110 0111 1000`
- 右移16位后 `h >>> 16`: `0000 0000 0000 0000 0001 0010 0011 0100`
- 异或运算 `h ^ (h >>> 16)`: `0001 0010 0011 0100 0100 0100 0100 1100`

结果是 `0x1234444C`。这个操作使得高位的信息被混合到了低位，从而提高了整个哈希值的随机性和均匀性。

### 结果的作用

通过这种方式，即使是连续的或模式相似的哈希值也会被更加均匀地分布到哈希表的不同桶中。这样可以显著减少因哈希冲突带来的性能问题，特别是在大数据集合和高并发的环境下，优化后的哈希函数能够提供更快的访问速度和更高的数据处理效率。