[toc]

## 1.排序算法

排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。为什么要对数据进行排序呢？因为有序数据通常能够被更高效地查找、分析和处理。



### 1.1 评价维度

**运行效率**：时间复杂度

**就地性**：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，最多只是使用固定的额外存储空间。这样做有以下好处：1. 空间复杂度：由于就地排序算法不需要额外的数据结构来存储大量的临时数据，因此其空间复杂度是O1。2.运行速度：不用额外的辅助数组，本身数组多被存放在缓存中，因此减少了内存的使用，提高了缓存的效率。

**稳定性**：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。

稳定排序很重要，如下面：A 19岁，D 19岁，不能说在对年龄排序后，A就到D的后面了。

```
# 输入数据是按照姓名排序好的
# (name, age)
  ('A', 19)
  ('B', 18)
  ('C', 21)
  ('D', 19)
  ('E', 23)

# 假设使用非稳定排序算法按年龄排序列表，
# 结果中 ('D', 19) 和 ('A', 19) 的相对位置改变，
# 输入数据按姓名排序的性质丢失
  ('B', 18)
  ('D', 19)
  ('A', 19)
  ('C', 21)
  ('E', 23)
```

**自适应性**：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。

自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性。

**是否基于比较**：基于比较的排序依赖比较运算符（<、=、>）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 𝑂(𝑛log⁡𝑛) 。而非比较排序不使用比较运算符，时间复杂度可达 𝑂(𝑛) ，但其通用性相对较差。



### 1.2 理想中的排序算法

运行快，就地排序，稳定，正向自适应，通用性好。