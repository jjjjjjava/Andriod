[toc]

## Activity介绍

### 1.Activity

Activity 是 Android 应用的基本构建块，代表单个屏幕。，其是View和Controller层，当然还包括对生命周期的管理：如 `onCreate`、`onStart`、`onResume`、`onPause`、`onStop`、`onDestroy` 

### 2.任务：

**任务** 是由一组 `Activity` 组成的集合，代表用户当前正在进行的一项工作。

1. 任务是由一组相互关联的 `Activity` 组成的，这些 `Activity` 共同完成一个用户任务。
2. 任务栈是一个先进后出（LIFO，Last In First Out）的堆栈结构，用于管理同一个任务中的 `Activity` 实例。
3. 每当启动一个新的 `Activity` 时，它会被推入任务栈的顶部；当用户按下返回键时，顶部的 `Activity` 会被弹出，显示下一个 `Activity`。

举例说明：

假设你在使用一个电商应用，浏览商品详情、查看购物车和结账的过程就是一个任务。在这个过程中，你的操作可能如下：

1. **打开应用**：

   - 你启动电商应用，`MainActivity` 显示商品列表。

   - 任务栈内容：

     ```
     MainActivity
     ```

2. **浏览商品详情**：

   - 你点击某个商品，启动 `ProductDetailActivity`，显示商品的详细信息。

   - 任务栈内容：

     ```
     ProductDetailActivity
     MainActivity
     ```

3. **查看购物车**：

   - 你点击“查看购物车”按钮，启动 `CartActivity`，显示购物车中的商品。

   - 任务栈内容：

     ```
     CartActivity
     ProductDetailActivity
     MainActivity
     ```

4. **进行结账**：

   - 你点击“结账”按钮，启动 `CheckoutActivity`，进行结账操作。

   - 任务栈内容：

     ```
     CheckoutActivity
     CartActivity
     ProductDetailActivity
     MainActivity
     ```

## Activity 生命周期

1. **Activity 启动**
   - **onCreate()**：应用第一次启动时调用。设置 UI 布局和进行初始化操作。例如，当你第一次打开微信时，微信的主界面布局在这里被加载。
   - **onStart()**：Activity 变得可见，但还没有准备好和用户互动。例如，微信的主界面已经显示，但还在加载数据，这时候你可能会看到一个加载动画。
   - **onResume()**：Activity 准备好和用户互动，位于前台。例如，微信主界面的数据加载完成，你可以开始点击和滑动。
2. **Activity 运行**
   - 当 Activity 正常运行时，用户可以与其互动。
3. **Activity 暂停**
   - **onPause()**：Activity 部分可见，用户无法互动。例如，另一个 Activity（如对话框）部分遮挡当前 Activity。
4. **Activity 停止**
   - **onStop()**：Activity 完全不可见，但仍然在内存中。例如，用户打开了另一个应用。
5. **Activity 销毁**
   - **onDestroy()**：Activity 被销毁，释放所有资源。这可能由于用户关闭 Activity 或系统为了回收内存而销毁 Activity。
6. **Activity 重启**
   - **onRestart()**：Activity 从停止状态重新启动。

### 举例：

#### 场景 1：打开应用

1. **onCreate()**
   - 应用第一次启动时调用。设置 UI 布局和进行初始化操作。
   - 例如，当你第一次打开微信时，微信的主界面布局在这里被加载。
2. **onStart()**
   - Activity 对用户可见，但还未准备好交互。
   - 例如，微信的主界面已经显示，但还在加载数据，这时候你可能会看到一个加载动画。
3. **onResume()**
   - Activity 准备好与用户交互，完全位于前台。
   - 例如，微信主界面的数据加载完成，你可以开始点击和滑动。

#### 场景 2：打开一个新 Activity

假设你在微信主界面（Activity A）上点击一个聊天对话，打开聊天界面（Activity B）：

1. **Activity A: onPause()**
   - 当前 Activity（微信主界面）部分不可见，准备打开新 Activity。
   - 例如，微信主界面即将被聊天界面覆盖。
2. **Activity B: onCreate()**
   - 聊天界面开始初始化，加载布局和数据。
   - 例如，聊天界面的消息列表和输入框开始加载。
3. **Activity B: onStart()**
   - 聊天界面对用户可见，但还未完全准备好交互。
   - 例如，消息列表已经显示，但图片和视频可能还在加载。
4. **Activity B: onResume()**
   - 聊天界面准备好与用户交互。
   - 例如，你可以开始输入消息和发送图片。
5. **Activity A: onStop()**
   - 主界面完全不可见。
   - 例如，微信主界面完全被聊天界面覆盖。

#### 场景 3：按下 Home 键

当你在微信的聊天界面（Activity B）中按下 Home 键回到桌面：

1. **Activity B: onPause()**
   - 聊天界面部分不可见。
   - 例如，微信聊天界面即将被桌面界面覆盖。
2. **Activity B: onStop()**
   - 聊天界面完全不可见。
   - 例如，桌面界面完全覆盖了微信聊天界面。

#### 场景 4：重新打开应用

当你从桌面重新打开微信（从停止状态到前台）：

1. **Activity B: onRestart()**
   - 聊天界面从停止状态重新启动。
   - 例如，微信聊天界面被恢复到前台。
2. **Activity B: onStart()**
   - 聊天界面对用户可见，但还未准备好交互。
   - 例如，微信聊天界面显示，但数据可能需要重新加载。
3. **Activity B: onResume()**
   - 聊天界面准备好与用户交互。
   - 例如，你可以继续输入和发送消息。

### 启动另一个 Activity

当一个 Activity 启动另一个 Activity 时（例如从 A 启动 B），其生命周期回调如下：

- A 的 `onPause()` 被调用。
- B 的 `onCreate()`、`onStart()` 和 `onResume()` 依次被调用。
- 如果 B 不是全屏（例如透明主题或对话框），则 A 的 `onStop()` 不会被调用；否则，A 的 `onStop()` 被调用。





## 保存和恢复 UI 状态

使用 `onSaveInstanceState()` 方法保存 Activity 的状态，当 Activity 被系统销毁并重新创建时，恢复状态可以提供更好的用户体验。

```kotlin
lateinit var textView: TextView
var gameState: String? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    gameState = savedInstanceState?.getString(GAME_STATE_KEY)
    setContentView(R.layout.activity_main)
    textView = findViewById(R.id.text_view)
}

override fun onRestoreInstanceState(savedInstanceState: Bundle?) {
    textView.text = savedInstanceState?.getString(TEXT_VIEW_KEY)
}

override fun onSaveInstanceState(outState: Bundle?) {
    outState?.run {
        putString(GAME_STATE_KEY, gameState)
        putString(TEXT_VIEW_KEY, textView.text.toString())
    }
    super.onSaveInstanceState(outState)
}
```

- **onCreate()**：初始化 `TextView` 并恢复先前保存的状态。
- **onRestoreInstanceState()**：在 `onCreate()` 之后调用，用于恢复 UI 状态。
- **onSaveInstanceState()**：保存当前的 `gameState` 和 `TextView` 内容，以便在 Activity 被销毁时保存数据。

这些方法确保了当设备旋转、内存不足或其他原因导致 Activity 被销毁和重新创建时，用户的操作和数据不会丢失。

### 成员变量声明

```kotlin
lateinit var textView: TextView
var gameState: String? = null
```

1. **lateinit var textView: TextView**
   - `lateinit` 关键字用于声明一个延迟初始化的非空类型变量。在这个例子中，`textView` 是一个 `TextView` 对象。
   - 延迟初始化意味着这个变量会在稍后某个时间点被初始化，而不是在声明时立即初始化。这对于像 `TextView` 这样的 UI 组件是有用的，因为它们通常在 `setContentView()` 之后才可用。
2. **var gameState: String? = null**
   - `gameState` 是一个可空类型的 `String` 变量，初始值为 `null`。
   - 这个变量用于保存游戏状态，可以在生命周期方法中保存和恢复。

### onCreate() 方法

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    gameState = savedInstanceState?.getString(GAME_STATE_KEY)
    setContentView(R.layout.activity_main)
    textView = findViewById(R.id.text_view)
}
```

1. **super.onCreate(savedInstanceState)**
   - 调用父类的 `onCreate` 方法，以确保 Activity 正确初始化。
2. **gameState = savedInstanceState?.getString(GAME_STATE_KEY)**
   - `savedInstanceState` 是一个 `Bundle` 对象，包含了先前保存的 Activity 状态。
   - 如果`savedInstanceState`不为空，那么使用 `getString(GAME_STATE_KEY)` 从 `Bundle` 中恢复先前保存的 `gameState` 值。如果 `savedInstanceState` 为 `null`，则 `gameState` 保持为 `null`。
3. **setContentView(R.layout.activity_main)**
   - 设置 Activity 的布局文件。`R.layout.activity_main` 指定了布局资源 ID。
4. **textView = findViewById(R.id.text_view)**
   - 初始化 `textView`，通过 ID 查找布局中的 `TextView` 组件。

### onRestoreInstanceState() 方法

```kotlin
override fun onRestoreInstanceState(savedInstanceState: Bundle?) {
    textView.text = savedInstanceState?.getString(TEXT_VIEW_KEY)
}
```

1. textView.text = savedInstanceState?.getString(TEXT_VIEW_KEY)
   - 从 `savedInstanceState` 中恢复 `TextView` 的文本内容。如果 `savedInstanceState` 不为 `null`，则从中获取 `TEXT_VIEW_KEY` 对应的字符串并设置给 `textView`。

### onSaveInstanceState() 方法

```kotlin
override fun onSaveInstanceState(outState: Bundle?) {
    outState?.run {
        putString(GAME_STATE_KEY, gameState)
        putString(TEXT_VIEW_KEY, textView.text.toString())
    }
    super.onSaveInstanceState(outState)
}
```

1. **outState?.run { ... }**
   - `run` 是一个作用域函数，如果 `outState` 不为 `null`，则执行块内代码。
2. **putString(GAME_STATE_KEY, gameState)**
   - 将当前的 `gameState` 值保存到 `outState` 中，使用键 `GAME_STATE_KEY`。
3. **putString(TEXT_VIEW_KEY, textView.text.toString())**
   - 将 `textView` 的当前文本内容保存到 `outState` 中，使用键 `TEXT_VIEW_KEY`。
4. **super.onSaveInstanceState(outState)**
   - 调用父类的 `onSaveInstanceState` 方法，以确保所有父类实现的状态保存逻辑也被执行。

### 总结

- `onCreate()` 方法用于初始化 Activity，包括设置布局和恢复先前保存的状态。
- `onRestoreInstanceState()` 方法在 `onCreate()` 之后调用，用于恢复 UI 状态。
- `onSaveInstanceState()` 方法在 Activity 可能被销毁之前调用，用于保存当前的状态。