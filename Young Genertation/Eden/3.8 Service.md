[toc]

## 1. Service

**Service** 是在后台执行长时间运行操作的组件，不提供用户界面。它主要用于执行需要保持运行的任务。

其主要分为启动和绑定两种模式

### 启动服务（Started Service）

**启动服务** 是指服务通过调用 `startService()` 方法启动，它主要用于执行一些后台任务，比如下载文件、播放音乐等，即使用户切换到其他应用程序，服务仍然继续运行。

#### 举例说明

**场景**：一个音乐播放应用，用户可以播放音乐并且切换到其他应用程序，音乐仍然会继续播放。

### 绑定服务（Bound Service）

**绑定服务** 是指通过调用 `bindService()` 方法启动的服务，主要用于提供客户端和服务之间的交互。当所有绑定的客户端解除绑定后，服务会自动停止。

#### 举例说明

**场景**：一个健身应用，用户可以通过应用中的Activity与设备的传感器服务进行交互，获取实时的运动数据。当用户关闭这个Activity时，服务也会停止。



## 2. 生命周期

![image-20240520183512980](../Pic/image-20240520183512980.png)

#### 启动服务（Unbounded Service）

1. Call to `startService()`：
   - 调用 `startService()` 方法。
2. onCreate()：
   - 服务被创建时调用。
3. onStartCommand()：
   - 服务启动并执行任务。
4. Service running：
   - 服务在后台运行，直到被停止。
5. onDestroy()：
   - 服务被停止前调用，用于清理资源。
6. Service shut down：
   - 服务关闭。

#### 绑定服务（Bound Service）

1. Call to `bindService()`：
   - 调用 `bindService()` 方法。
2. onCreate()：
   - 服务被创建时调用。
3. onBind()：
   - 服务绑定时调用，返回 `IBinder` 对象。
4. Clients are bound to service：
   - 客户端绑定到服务，可以进行交互。
5. onUnbind()：
   - 客户端解绑时调用。
6. onDestroy()：
   - 服务被停止前调用，用于清理资源。
7. Service shut down：
   - 服务关闭。



### 服务的启动模式

- **START_NOT_STICKY**：
  - 如果系统在 `onStartCommand()` 返回后终止服务，则除非有新的启动请求，否则系统不会重建服务。
  - 适用于不需要在终止后重启的任务。
- **START_STICKY**：
  - 如果系统在 `onStartCommand()` 返回后终止服务，则会重建服务并调用 `onStartCommand()`，但不会重新传递最后一个 Intent。
  - 适用于需要持续运行的任务，例如音乐播放器。
- **START_REDELIVER_INTENT**：
  - 如果系统在 `onStartCommand()` 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 `onStartCommand()`。
  - 适用于需要恢复执行中断任务的服务，例如下载文件。

## 3. 启用前台服务

启用前台服务可以确保服务在系统内存不足时不会被终止，同时它会在通知栏显示一个持续的通知，提醒用户该服务正在运行。这对于需要长时间运行的重要后台任务（如音乐播放、位置跟踪等）特别有用。

### 启用前台服务的步骤

1. **声明权限**：在 `AndroidManifest.xml` 文件中声明前台服务权限。
2. **创建通知**：创建一个 `Notification`，用于显示在通知栏中。
3. **启动前台服务**：调用 `startForeground` 方法，将服务提升为前台服务。

### 具体步骤和代码示例

#### 1. 在 `AndroidManifest.xml` 中声明权限

在应用的 `AndroidManifest.xml` 文件中添加前台服务权限。

```
xml
复制代码
<uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
```

#### 2. 创建通知

创建一个通知，用于在通知栏中显示前台服务的状态。

```
java复制代码// 创建一个通知渠道（适用于 Android 8.0 及以上）
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    NotificationChannel channel = new NotificationChannel(
            "foreground_service_channel",
            "Foreground Service Channel",
            NotificationManager.IMPORTANCE_DEFAULT
    );
    NotificationManager manager = getSystemService(NotificationManager.class);
    manager.createNotificationChannel(channel);
}

// 创建通知
Notification notification = new NotificationCompat.Builder(this, "foreground_service_channel")
        .setContentTitle("前台服务标题")
        .setContentText("前台服务正在运行")
        .setSmallIcon(R.drawable.ic_service_icon)
        .setContentIntent(pendingIntent)
        .build();

// 创建一个 PendingIntent，用于通知点击事件
Intent notificationIntent = new Intent(this, ExampleActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
```

#### 3. 启动前台服务

在服务的 `onStartCommand` 方法中调用 `startForeground` 方法，将服务提升为前台服务。

```
java复制代码public class MyForegroundService extends Service {
    private static final int ONGOING_NOTIFICATION_ID = 1;

    @Override
    public void onCreate() {
        super.onCreate();

        // 创建通知渠道（适用于 Android 8.0 及以上）
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(
                    "foreground_service_channel",
                    "Foreground Service Channel",
                    NotificationManager.IMPORTANCE_DEFAULT
            );
            NotificationManager manager = getSystemService(NotificationManager.class);
            manager.createNotificationChannel(channel);
        }

        // 创建通知
        Notification notification = new NotificationCompat.Builder(this, "foreground_service_channel")
                .setContentTitle("前台服务标题")
                .setContentText("前台服务正在运行")
                .setSmallIcon(R.drawable.ic_service_icon)
                .setContentIntent(pendingIntent)
                .build();

        // 启动前台服务
        startForeground(ONGOING_NOTIFICATION_ID, notification);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // 处理服务启动逻辑
        return START_NOT_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // 处理服务销毁逻辑
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null; // 前台服务通常不需要绑定
    }
}
```