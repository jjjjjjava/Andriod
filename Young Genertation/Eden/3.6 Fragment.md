[toc]

## 特点

Fragment 是 Android 中一种更轻量级的 UI 组件，可以嵌入到 Activity 中，允许灵活且动态地管理和切换用户界面的一部分。它具有以下特点和用法：

#### 特点

1. **解决 Activity 间的切换不流畅**
   - 使用 Fragment 可以在同一个 Activity 中进行切换，而不需要启动新的 Activity，从而提高切换的流畅性。
2. **轻量切换**
   - Fragment 的切换比 Activity 的切换更轻量，因为它们共享同一个 Activity 的资源和上下文，而不需要重新创建整个 Activity。
3. **接收返回结果**
   - Fragment 可以使用 `startActivityForResult` 方法启动另一个 Activity，并接收返回结果，这类似于 Activity 的行为。
   - **注意**：普通的 `View` 无法直接接收 `startActivityForResult` 的结果。
4. **事务管理**
   - Fragment 的事务（如添加、移除、替换）必须在 Activity 保存其状态之前使用 `commit()` 方法提交。
   - 如果在保存状态之后提交事务，会引发异常，因为在恢复 Activity 时，提交后的状态可能会丢失。
   - 如果确定丢失提交无关紧要，可以使用 `commitAllowingStateLoss()` 方法提交事务。





啥意思？就是说现在Activity因为其本身资源较大，切换的时候不流畅。因此出现了Fragment，其辅助activity进行切换，这样切屏就很流程？



我有些不理解了，我原本疑问Fragment是用来进行activity之间的切换的，但是你这样一说，它好像是进行activity内部的不同界面的切换。就好像：微信：我的activity是主界面，内部不同界面的切换是指我切入到跟一个朋友的聊天中。但是如果将activity视作一个屏幕，那么这不还是不同屏幕间的切换吗？就是：切换的最小单元是activity？

### 例子分析：微信的主界面和聊天界面

- 主界面

  ：包含多个选项卡，每个选项卡可以是一个 Fragment。例如，“聊天列表”是一个 Fragment，“联系人”是另一个 Fragment。

  - 在用户切换选项卡时，实际上是在同一个 Activity 内切换不同的 Fragment。

- **聊天界面**：当用户从聊天列表中选择一个聊天对象时，会启动一个新的 Activity，显示具体的聊天内容。





1. **Fragment 是在同一个 Activity 内进行界面切换的最小单元**：
   - 在微信的例子中，主界面的不同选项卡（如“聊天列表”、“联系人”）是不同的 Fragment，它们在同一个 Activity 内切换。
2. **Activity 是更大的界面单元**：
   - 当从聊天列表进入具体的聊天界面时，会启动一个新的 Activity，这种切换是 Activity 级别的。
3. **Fragment 提高了灵活性和复用性**：
   - 可以在同一个 Activity 内动态地加载和替换不同的 Fragment。
   - 可以在不同的 Activity 中复用相同的 Fragment。
4. **最小切换单元是 Fragment**，而 Activity 是较大的切换单元：
   - 在一个 Activity 内，Fragment 是最小的切换单元。
   - 在应用程序的结构上，Activity 是用于更大范围的切换（例如从主界面到聊天界面）。





## 生命周期

#### Fragment 添加到 Activity 时的生命周期

1. **onAttach()**
   - **调用时机**：Fragment 被附加到 Activity 上时调用。
   - **作用**：你可以获取 Fragment 的宿主 Activity，进行初步的设置。
2. **onCreate()**
   - **调用时机**：Fragment 被创建时调用，但还没有创建视图。
   - **作用**：用于初始化 Fragment，例如保留实例状态、设置初始参数。
3. **onCreateView()**
   - **调用时机**：为 Fragment 创建视图层次结构时调用。
   - **作用**：在这个方法中创建和返回与该 Fragment 相关的 View。
4. **onActivityCreated()**
   - **调用时机**：宿主 Activity 的 `onCreate()` 方法已经返回时调用。
   - **作用**：表示 Activity 已完成其 `onCreate()` 方法中的初始化工作，此时可以进行与 Activity 相关的进一步初始化。
5. **onStart()**
   - **调用时机**：Fragment 可见时调用。
   - **作用**：开始处理与用户交互的操作。
6. **onResume()**
   - **调用时机**：Fragment 可以与用户交互时调用。
   - **作用**：Fragment 进入活动状态，可以响应用户输入和事件。

#### Fragment 活动时的生命周期

- Fragment is active
  - 在这个阶段，Fragment 处于活动状态，可以与用户交互。

#### Fragment 被移除或替换时的生命周期

1. **onPause()**
   - **调用时机**：Fragment 不再处于前台，无法与用户交互时调用。
   - **作用**：暂停 Fragment 的界面更新和动画，保存必要的数据。
2. **onStop()**
   - **调用时机**：Fragment 不再可见时调用。
   - **作用**：释放资源，停止动画、线程等耗费资源的操作。
3. **onDestroyView()**
   - **调用时机**：与 Fragment 相关的视图被移除时调用。
   - **作用**：清理与视图相关的资源，例如解除视图绑定。
4. **onDestroy()**
   - **调用时机**：Fragment 被销毁时调用。
   - **作用**：进行 Fragment 的最终清理，例如停止后台任务，清理资源。
5. **onDetach()**
   - **调用时机**：Fragment 从 Activity 中被移除时调用。
   - **作用**：进行与 Activity 解除关联的最终清理。



![img](../Pic/31722863.jpg)





![img](../Pic/68747470733a2f2f646576656c6f7065722e616e64726f69642e676f6f676c652e636e2f696d616765732f61637469766974795f667261676d656e745f6c6966656379636c652e706e67.png)

## 与activity通信

Fragment 与其宿主 Activity 通信的一个好方法是使用回调接口。通过这种方式，Fragment 可以将事件传递给宿主 Activity，让 Activity 来处理这些事件。

### 1. 定义接口

首先，在 Fragment 中定义一个回调接口，这个接口包含了你希望 Activity 实现的方法。在您的例子中，这个接口是 `OnArticleSelectedListener`。

```java
public interface OnArticleSelectedListener {
    void onArticleSelected(Uri articleUri);
}
```

### 2. 在 Fragment 中声明接口类型的成员变量

在 Fragment 中声明一个接口类型的成员变量。

```java
public class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;
    ...
}
```

### 3. 在 Fragment 的 `onAttach` 方法中获取接口的实例

在 `onAttach` 方法中，将宿主 Activity 强制转换为接口类型，并将其赋值给接口类型的成员变量。这样，你就可以通过该成员变量调用 Activity 实现的接口方法。

```java
@Override
public void onAttach(Context context) {
    super.onAttach(context);
    try {
        mListener = (OnArticleSelectedListener) context;
    } catch (ClassCastException e) {
        throw new ClassCastException(context.toString() + " must implement OnArticleSelectedListener");
    }
}
```

注意：从 Android API 23 开始，`onAttach(Activity activity)` 已被弃用，建议使用 `onAttach(Context context)`。

### 4. 在需要时调用接口方法

当需要通知 Activity 时，通过接口类型的成员变量调用接口方法。

```java
// Assume that an article is selected
public void someMethodThatSelectsArticle(Uri articleUri) {
    if (mListener != null) {
        mListener.onArticleSelected(articleUri);
    }
}
```

### 5. 在 Activity 中实现接口

确保宿主 Activity 实现了这个接口，并在接口方法中处理来自 Fragment 的回调。

```java
public class MainActivity extends AppCompatActivity implements FragmentA.OnArticleSelectedListener {
    @Override
    public void onArticleSelected(Uri articleUri) {
        // Handle the article selection
    }
}
```

### 完整示例

综合上面的步骤，这里是一个完整的示例：

**FragmentA.java**

```java
public class FragmentA extends ListFragment {
    OnArticleSelectedListener mListener;

    // Container Activity must implement this interface
    public interface OnArticleSelectedListener {
        void onArticleSelected(Uri articleUri);
    }

    @Override
    public void onAttach(Context context) {
        super.onAttach(context);
        try {
            mListener = (OnArticleSelectedListener) context;
        } catch (ClassCastException e) {
            throw new ClassCastException(context.toString() + " must implement OnArticleSelectedListener");
        }
    }

    // Method to simulate article selection
    public void selectArticle(Uri articleUri) {
        if (mListener != null) {
            mListener.onArticleSelected(articleUri);
        }
    }
}
```

**MainActivity.java**

```java
public class MainActivity extends AppCompatActivity implements FragmentA.OnArticleSelectedListener {
    @Override
    public void onArticleSelected(Uri articleUri) {
        // Handle the article selection, e.g., display it in another Fragment
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // Add FragmentA to the Activity
        if (savedInstanceState == null) {
            getSupportFragmentManager().beginTransaction()
                .replace(R.id.fragment_container, new FragmentA())
                .commit();
        }
    }
}
```



原理：在Fragment中定义接口，声明接口类型成员变量。同时在Fragment的OnAttach方法中将Activity对象强转为接口类型保存到接口类型成员变量中，这样就可以调用Activity中该接口的实现了。

然后在Fragment内部某个回调中调用Activity中该接口的实现。再在内部定义一个处理事件的逻辑，处理这个事件时会调用这个回调。

所以当Fragment中出现某个事件时，最终Activity可以知道并去处理用户自定义的逻辑。这样做：当用户操作Fragment中某个视图时，可以做到更新整个Activity。比如：点击微信主界面中聊天对象的头像。可以更新Activity。





## 进阶

我们以一个具体的例子来演示：在微信主界面中点击聊天对象的头像，更新主界面的某个视图或启动新的 Activity。

#### Step 1: 定义接口

在 Fragment 中定义一个接口，用于通知 Activity 用户点击了头像。

```java
public interface OnAvatarClickListener {
    void onAvatarClick(Uri avatarUri);
}
```

#### Step 2: 声明接口类型成员变量

在 Fragment 中声明一个接口类型的成员变量。

```java
public class ChatFragment extends Fragment {
    OnAvatarClickListener mListener;

    // Define the interface
    public interface OnAvatarClickListener {
        void onAvatarClick(Uri avatarUri);
    }

    // Other Fragment code...
}
```

#### Step 3: 在 `onAttach` 方法中强制类型转换

在 `onAttach` 方法中，将 `Context` 强制转换为 `OnAvatarClickListener`，并赋值给 `mListener`。

```java
@Override
public void onAttach(Context context) {
    super.onAttach(context);
    try {
        mListener = (OnAvatarClickListener) context;
    } catch (ClassCastException e) {
        throw new ClassCastException(context.toString() + " must implement OnAvatarClickListener");
    }
}
```

#### Step 4: 在 Fragment 中触发事件

在 Fragment 中某个事件处理方法中调用接口方法。例如，当用户点击聊天对象的头像时。

```java
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_chat, container, false);

    // Assume avatarImageView is the ImageView displaying the avatar
    ImageView avatarImageView = view.findViewById(R.id.avatarImageView);
    avatarImageView.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Uri avatarUri = Uri.parse("content://avatars/123"); // Assume this is the URI of the avatar
            if (mListener != null) {
                mListener.onAvatarClick(avatarUri);
            }
        }
    });

    return view;
}
```

#### Step 5: 在 Activity 中实现接口

在宿主 Activity 中实现 `OnAvatarClickListener` 接口，处理点击事件。

```java
public class MainActivity extends AppCompatActivity implements ChatFragment.OnAvatarClickListener {
    @Override
    public void onAvatarClick(Uri avatarUri) {
        // Handle the avatar click, e.g., display a larger version of the avatar or show profile details
        Intent intent = new Intent(this, ProfileActivity.class);
        intent.setData(avatarUri);
        startActivity(intent);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // Add ChatFragment to the Activity
        if (savedInstanceState == null) {
            getSupportFragmentManager().beginTransaction()
                .replace(R.id.fragment_container, new ChatFragment())
                .commit();
        }
    }
}
```



1. `setContentView(R.layout.activity_main)` 设置了 `Activity` 的布局，这个布局文件中包含了一个 `fragment_container` 容器视图，供我们稍后添加 `Fragment`。



2. **检查 `savedInstanceState`**:

```java
if (savedInstanceState == null) {
```

- `savedInstanceState` 是 `Activity` 状态恢复的一个机制。它在 `Activity` 被重新创建时保存之前的状态。
- 这个检查用于确保只有在 `Activity` 第一次创建时才添加 `Fragment`，防止在旋转屏幕或其它导致 `Activity` 重新创建的情况下重复添加 `Fragment`。

- `getSupportFragmentManager()` 获取 `FragmentManager`，用于管理 `Fragment`。
- `beginTransaction()` 开始一个 `Fragment` 事务。



3. **添加 `ChatFragment`**:

```java
.replace(R.id.fragment_container, new ChatFragment())
```

- `replace(R.id.fragment_container, new ChatFragment())` 将新的 `ChatFragment` 实例添加到 `fragment_container` 容器视图中。如果容器视图中已经有 `Fragment`，则替换掉它。

4. **提交事务**:

```java
.commit();
```

- `commit()` 提交事务，应用所有的 `Fragment` 更改。