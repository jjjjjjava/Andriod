[toc]

## Binder

**Binder** 是 Android 中的一个类，实现了 **IBinder** 接口。作为 Android 系统中的一种高效、灵活的进程间通信（IPC）机制，Binder 连接了 Android 系统的各个部分，从应用层到系统服务层，为其提供了一种高效且安全的通信方式。

### Binder 的工作原理

Binder 的工作原理可以从以下几个方面进行阐述：

1. **C/S 架构**：Binder 本身是基于客户端-服务器（C/S）架构的。这与 Android 的整体架构非常契合。在这种架构中，客户端通过 Binder 与服务器进行通信，请求服务和数据。
2. **内存拷贝**：Binder 通信只需要一次数据拷贝，而传统的 IPC 机制（如管道、消息队列、Socket）通常需要两次数据拷贝。这是因为 Binder 采用了共享内存的方式，客户端和服务器直接共享同一块物理内存区域。
3. **安全性**：Binder 通信过程中会自动传递调用者的身份标识（UID/GID），服务器端可以轻松地获取客户端的身份，从而进行安全检查。这为系统提供了更好的安全性。

### Binder 通信的基本流程

1. **客户端发起请求**：客户端通过 Binder 对象发起请求。
2. **数据拷贝**：客户端的数据通过 Binder 驱动程序（位于内核空间）拷贝到服务器端。
3. **服务器处理请求**：服务器端接收到请求并进行相应的处理。
4. **返回结果**：服务器端处理完请求后，将结果通过 Binder 驱动程序返回给客户端。

### Binder 的架构和组成

Binder 架构主要由以下几个部分组成：

1. **Binder 驱动**：位于 Linux 内核中，负责管理 Binder 的创建、销毁和数据传输。
2. **ServiceManager**：系统服务管理器，负责管理系统中的各种服务。它也是通过 Binder 实现的。
3. **Binder Proxy**：客户端的代理对象，通过它可以向服务器发起请求。
4. **Binder Stub**：服务器的 Binder 对象，处理客户端的请求并返回结果。



### 不太理解：Binder 通信只需要一次数据拷贝，而传统的 IPC 机制（如管道、消息队列、Socket）通常需要两次数据拷贝。

#### 传统 IPC 机制

传统的 IPC 机制（如管道、消息队列、Socket）在数据传递过程中，通常需要经过两次数据拷贝：

1. **从用户空间到内核空间**：
   - 发送进程将数据从用户空间拷贝到内核空间。例如，通过 `write()` 系统调用，数据被拷贝到内核缓冲区。
2. **从内核空间到用户空间**：
   - 接收进程将数据从内核空间拷贝到用户空间。例如，通过 `read()` 系统调用，数据从内核缓冲区拷贝到接收进程的用户空间。

这种双重拷贝的开销包括：

- 数据在两个不同的内存空间之间的拷贝操作。
- 系统调用的上下文切换。

#### Binder IPC 机制

Binder 通信机制通过共享内存的方式减少了数据拷贝的次数，具体如下：

1. 一次数据拷贝：
   - 发送进程将数据从用户空间拷贝到内核空间的共享内存区域。
   - 接收进程直接从共享内存区域读取数据，无需再进行第二次拷贝。

这种方式的优势在于：

- 减少了一次从内核空间到用户空间的拷贝。
- 提高了数据传输的效率。



## Binder原理

就是，它的原理是基于共享内存，实际工作原理是这样的，有客户端和服务端，客户端结构化数据，然后调用Binder驱动程序，其会将数据从客户端的用户空间拷贝到共享内存空间中，并发送客户端请求给服务端，然后服务器端接收到请求后，访问共享空间，获取对应的数据，并执行相应的处理。最后将结果通过Binder驱动程序返回给客户端。具体原理是：rpc，客户端将数据拷贝到内核共享内存空间后，进行rpc调用，服务端访问共享内存处理数据，将结果返回。



### Binder 的工作原理详解

#### 1. 客户端调用

- 客户端调用方法（例如 `startService`），这个调用会被封装成一个 `Parcel` 对象。`Parcel` 是一种用于序列化数据的容器，可以包含基本数据类型和实现了 `Parcelable` 接口的对象。

#### 2. 通过 BinderProxy 发送请求

- 客户端通过 `BinderProxy` 发起请求。`BinderProxy` 是客户端的代理对象，负责与 Binder 驱动程序通信。

#### 3. 数据拷贝到内核空间

- `BinderProxy` 将封装好的 `Parcel` 通过 `BpBinder`（Binder Proxy Binder）传递给内核中的 Binder 驱动程序。此时，数据从用户空间拷贝到内核空间的共享内存区域。

#### 4. 内核空间处理请求

- 内核中的 Binder 驱动程序接收请求，并将其放入服务端进程的等待队列中。

#### 5. 服务端接收请求

- 服务端进程中的 `BBinder`（Binder Binder）接收到请求，并通过 `Parcel` 反序列化数据。服务端的 Binder 对象负责处理具体的业务逻辑。

#### 6. 服务端处理请求并返回结果

- 服务端处理完请求后，将结果再次封装到 `Parcel` 中，通过 `BBinder` 发送回内核中的 Binder 驱动程序。

#### 7. 数据拷贝回客户端

- Binder 驱动程序将结果数据从内核空间的共享内存区域拷贝回客户端的用户空间。

#### 8. 客户端接收结果

- 客户端的 `BinderProxy` 接收到返回的 `Parcel`，并将结果数据反序列化，返回给调用方。

### 原理中的共享内存和 RPC

- **共享内存**：在整个过程中，Binder 利用了共享内存机制来减少数据拷贝的次数。具体来说，客户端的数据首先从用户空间拷贝到内核空间的共享内存区域，然后服务端直接从共享内存读取数据进行处理。这减少了传统 IPC 机制中的一次拷贝操作。
- **RPC 调用**：Binder 实现了类似 RPC 的机制，使得客户端可以像调用本地方法一样调用远程进程中的方法。尽管通信是在本地完成的，但 Binder 提供了透明的接口，使开发者无需关心底层的通信细节。



## Binder执行流程

![img](../Pic/687474703a2f2f6769747975616e2e636f6d2f696d616765732f62696e6465722f62696e6465725f73746172745f736572766963652f62696e6465725f6970635f617263682e6a7067.jpeg)