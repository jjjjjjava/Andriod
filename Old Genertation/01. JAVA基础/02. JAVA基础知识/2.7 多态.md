[toc]

## 精简版

1. 多态的核心概念
   1. **父类引用指向子类对象**：这允许你使用父类类型的引用来指向一个子类的实例。这种机制的好处是你可以编写更通用的代码来处理不同的子类对象。
   2. **方法调用的行为**：当通过父类引用调用方法时，实际执行的是子类重写后的方法（如果有重写的话）。这种行为称为“动态绑定”或“后期绑定”，意味着方法调用在运行时解析，而不是在编译时。
   3. **子类独有的方法**：如果子类有一些父类中没有的方法，那么这些方法不能通过父类引用直接访问。这是因为父类引用的类型决定了它能调用哪些方法。

2. 多态的底层原理：
   1. 虚函数表：每个类都有一个对应的虚方法表。这个表在类的每个对象中都有一个指针指向它（通常是对象内存布局的一部分）。
   2. 动态绑定：编译时，编译器并不总是能确定调用哪个类的方法（因为具体的对象类型直到运行时才确定），所以在运行时进行这一决定的机制称为动态绑定。
   3. 总结：子类的虚方法表中- 将包含指向这些重写方法的指针；如果Dog类没有重写某些方法，则它的虚方法表将包含指向Animal类中相应方法实现的指针。而调用Animal myAnimal = new Dog();是由于它实际指向的是一个Dog对象，所以该调用将通过Dog对象的vptr解析到Dog的虚方法表，从而执行Dog类中makeSound()方法的实现。



### 多态的基本概念

1. **父类引用指向子类对象**：这允许你使用父类类型的引用来指向一个子类的实例。这种机制的好处是你可以编写更通用的代码来处理不同的子类对象。
2. **方法调用的行为**：当通过父类引用调用方法时，实际执行的是子类重写后的方法（如果有重写的话）。这种行为称为“动态绑定”或“后期绑定”，意味着方法调用在运行时解析，而不是在编译时。
3. **子类独有的方法**：如果子类有一些父类中没有的方法，那么这些方法不能通过父类引用直接访问。这是因为父类引用的类型决定了它能调用哪些方法。





### 举例

### 父类和子类定义

首先，我们定义一个基础类 `Animal`，这个类有一个方法 `makeSound()`。

```
class Animal {
    void makeSound() {
        System.out.println("Some sound");
    }
}
```

接下来，我们定义两个继承自 `Animal` 的子类 `Dog` 和 `Cat`，这两个子类将重写 `makeSound` 方法。

```
class Dog extends Animal {
    void makeSound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    void makeSound() {
        System.out.println("Meow");
    }
}
```

### 2. 多态的使用

现在，我们将演示如何使用父类的引用来指向子类的对象，并调用这些对象的方法。

```
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.makeSound();  // Outputs: Bark

        myAnimal = new Cat();
        myAnimal.makeSound();  // Outputs: Meow
    }
}
```

在这个例子中，`myAnimal` 是 `Animal` 类型的引用，但它可以指向 `Dog` 和 `Cat` 对象。根据指向的对象的实际类型，调用的 `makeSound()` 方法是在相应的子类中重写的版本。这演示了多态性——同一个方法调用（`makeSound()`），在不同的对象上执行时，可以表现出不同的行为。

### 3. 子类独有的方法

如果 `Dog` 类中有一个独特的方法 `fetch()`，父类 `Animal` 中没有这个方法，那么你不能通过 `Animal` 类型的引用来直接调用这个方法。

```
class Dog extends Animal {
    void makeSound() {
        System.out.println("Bark");
    }

    void fetch() {
        System.out.println("Fetching the ball!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.makeSound();  // Outputs: Bark

        // 下面的调用将会产生编译错误
        // myAnimal.fetch();  // Error: cannot find symbol
    }
}
```

如果你确实需要调用 `fetch()` 方法，你必须先将 `myAnimal` 引用向下转型为 `Dog` 类型，但这种操作应谨慎进行，因为它需要确保引用确实指向了 `Dog` 对象。

```
((Dog)myAnimal).fetch();  // Outputs: Fetching the ball!
```

## 底层原理

这是因为动态绑定和虚函数表的机制。

在真正运行时，JVM会去虚函数表中查找对应的函数指针。每个类都拥有自己的虚函数表，其中包含了指向该类中所有动态绑定（多态的）方法的指针，当创建一个类的对象时，每个对象都会包含一个指向其类虚函数表的指针。（虚函数表）

这里JVM会检查`a`的实际类型是`Dog`，然后从`Dog`的方法表中查找`makeSound`方法并执行它。这保证了不管`a`变量的编译时类型是什么，运行时调用的总是实际对象（`Dog`）的`makeSound`方法。（动态绑定）

### 首先请了解以下机制：

#### 类型系统和继承

在面向对象的语言中，类型系统允许一个类型的变量（如父类类型的引用）持有另一个类型的对象（如子类的实例），只要这两个类型在继承层次中有关联。这种机制是多态的基础。

#### 动态绑定与虚方法表（vtable）

动态绑定是实现多态的核心机制之一。编译时，编译器并不总是能确定调用哪个类的方法（因为具体的对象类型直到运行时才确定），所以在运行时进行这一决定的机制称为动态绑定。

在许多面向对象的语言中，如C++、Java、C#等，动态绑定是通过一个称为虚方法表（vtable）的结构实现的。每个类都有一个vtable，这是一个函数指针数组，其中包含了指向该类虚方法的指针。

##### **虚方法表（vtable）的工作原理：**

1. **类结构**：每个类都有一个对应的虚方法表。这个表在类的每个对象中都有一个指针指向它（通常是对象内存布局的一部分）。
2. **对象实例化**：当一个类的对象被创建时，对象会包含一个指向其类虚方法表的指针。
3. **方法调用**：当通过一个类的引用调用一个虚方法时，实际上是通过引用对象的虚方法表来查找并调用适当的方法实现。

### 让我们来介绍一下原理

#### 虚方法表（vtable）和类的关系

每个具有虚方法的类都有一个对应的虚方法表（vtable），这个表存储了指向该类的所有虚方法的指针。这意味着每个子类通常也会有自己的虚方法表，尤其是当子类覆盖（重写）了父类的虚方法时。

#### 创建对象时的虚方法表指针

当你创建一个类的对象时，该对象内部会包含一个指针（通常称为vptr，虚指针），这个指针指向该类的虚方法表。这允许在运行时通过该表动态地解析方法调用。

#### 父类和子类对象的虚方法表

- **父类对象**：当你创建一个父类`Animal`的实例时，该对象的vptr指向`Animal`类的虚方法表。这个表包含了`Animal`类中所有虚方法的实现。
- **子类对象**：当你创建一个子类`Dog`的实例时，该对象的vptr将指向`Dog`类的虚方法表，而不是`Animal`类的虚方法表。如果`Dog`类重写了`Animal`类的方法，那么`Dog`的虚方法表将包含指向这些重写方法的指针；如果`Dog`类没有重写某些方法，则它的虚方法表将包含指向`Animal`类中相应方法实现的指针。

### 方法调用的动态解析

当通过父类引用调用虚方法时，如：

```
Animal myAnimal = new Dog();
myAnimal.makeSound();
```

即使`myAnimal`是`Animal`类型的引用，由于它实际指向的是一个`Dog`对象，所以该调用将通过`Dog`对象的vptr解析到`Dog`的虚方法表，从而执行`Dog`类中`makeSound()`方法的实现。这就是动态绑定的工作原理，它允许在运行时根据对象的实际类型来选择方法的具体实现。



总结：

关键在于动态绑定和虚方法表，

在运行时确定调用哪个类的方法，

子类的虚方法表中- 将包含指向这些重写方法的指针；如果Dog类没有重写某些方法，则它的虚方法表将包含指向Animal类中相应方法实现的指针。而调用Animal myAnimal = new Dog();是由于它实际指向的是一个Dog对象，所以该调用将通过Dog对象的vptr解析到Dog的虚方法表，从而执行Dog类中makeSound()方法的实现。
