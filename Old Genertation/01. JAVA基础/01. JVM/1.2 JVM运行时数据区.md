[toc]

## 精简版

JVM运行时的数据区如下：

1. 程序计数器区：JVM中每运行一个线程，都会在程序计数器区中为其分配一个程序计数器，存放当前执行到的字节码指令的地址（如果是Native方法，则程序计数器的值为空）

2. JAVA虚拟机栈区：JVM中每运行一个线程，都会在JAVA虚拟机栈区中为线程分配一个虚拟机栈，当其执行函数时会在虚拟机栈中创建一个栈帧。栈帧中存放有：局部变量表，操作数栈，动态链接（指向运行时常量池中该栈帧所属方法的引用），方法出口，

3. JAVA堆：主要用于存放对象

4. 本地方法栈：其跟虚拟机栈相似，只不过一个保存的是字节码对应的Java方法，另一个则是专门支持Native方法，即那些通常用C或C++编写，并通过Java本地接口（JNI）调用的方法。抛出的异常和上面相同。

5. 方法区：主要包括类的元信息，运行时常量池（符号引用，字面量），JIT解释的机器码，静态变量


其实就是：指令，数据，类信息

堆和栈都只是内存中的一块区域，为什么出现两个不同的区域，这是为了管理变量的生命周期。栈负责处理局部变量，堆负责处理生命周期超越局部的。 同时，栈区分配效率高于堆区，因为栈区只需要进行指针的移动即可。而堆区？需要进行遍历，找到可用的段，分配空间，处理剩余空间（形成新的段或合并）。其比栈区复杂很多。



运行时常量池保存的是：在程序运行过程中被频繁使用的固定值：

字面量：

- 编译时，`1024` 被存储在类文件的常量池中。
- 类加载时，常量池被解析，并在运行时常量池中表示 `1024`。
- 运行时，当 JVM 执行 `int a = 1024;` 时，为 `a` 分配 4 字节的存储空间，并将 `1024` 赋值给 `a`。

## 1. 运行时数据区

### 程序计数器

程序计数器可以理解为cpu的程序计数器，都记录了执行到的指令的位置，不过那个是每个cpu都有，而JAVA中的程序计数器则是每个线程都有。



**其用于记录当前线程执行的字节码的具体位置**。如果执行的是Java方法，**程序计数器记录的是字节码指令的地址；如果是Native方法，则程序计数器的值为空**。

**每个线程都有自己的程序计数器**。

同时：此内存区域是唯一一个在Java虚拟机规范中**没有规定任何OutOfMemoryError**情况的区域。



为什么Java虚拟机（JVM）设计中每个线程都有自己的程序计数器

1. **高效的线程切换**：如果使用全局唯一的程序计数器，那么在每次线程切换时，都需要保存当前线程的程序计数器状态，并恢复即将执行的线程的程序计数器状态，这会增加线程切换的开销。而线程私有的程序计数器简化了这一过程，每次线程切换时无需额外的保存和恢复操作，因为每个线程的程序计数器独立存在。
2. **减少竞争和锁的需求**：如果程序计数器是全局共享的，那么每次线程访问或修改程序计数器时，都必须进行同步控制，以避免竞争条件和数据不一致的问题。这会引入锁或其他同步机制，从而降低程序的性能。线程私有的程序计数器避免了这种复杂性，每个线程访问自己的计数器无需加锁，从而提高了性能。



为什么：如果线程正在执行的是一个 Native 方法，这个计数器值则为空

1. **其实根本原因是Native方法通常是直接编译成宿主机器的本地指令执行，而不是JVM解释执行的字节码。**这些方法直接运行在操作系统层面。因此，JVM内部的程序计数器不再是有效的工具来指示执行进度，因为它只能跟踪Java字节码指令。



为什么：此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

1. **其实根本原因就是程序计数器这个内存区域的数据结构太容易了**，可能只有线程字节码的起始地址，当前的执行位置，总体的大小。它不需要很多的内存空间，不存在超出内存错误的这个情况。



### JAVA虚拟机栈

其实就是很简单，类似线程的栈空间一样，每个线程都有一个，把方法看做函数，每次调用方法都会创建一个栈帧，里面存放一些方法执行时的临时数据。然后当方法调用完成后，栈帧会被销毁。



这些临时数据主要包括：**局部变量表、操作数栈、动态链接、方法出口**，也就是说：每个方法调用时JVM都会从虚拟机栈中创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口。

#### 局部变量表（Local Variables Table）

局部变量表是栈帧的一个组成部分，用于存储所有方法参数和方法内定义的局部变量。**这个表的大小是在编译时期确定的，并在方法运行期间不会改变**。局部变量表的容量以变量槽（Variable Slot）为单位计算：

- `long`和`double`类型的数据由于占用更多的内存，因此每个需要两个变量槽，其余均是一个变量槽。



局部变量表大小被确定好，是因为方法内部的局部变量在编写代码时就已经确定好了

#### 操作数栈（Operand Stack）

操作数栈也是栈帧的核心部分，它是一个后进先出（LIFO）的栈。Java虚拟机执行引擎在执行字节码指令时，会对操作数栈进行推送（push）和弹出（pop）操作：

操作数：a+b，a和b就是操作数，就是数据。

举例说明

```
int a = 10;
int b = 20;
int c = a + b;
```

在字节码层面，这可能对应如下操作：

1. 将变量`a`的值加载到操作数栈顶。
2. 将变量`b`的值加载到操作数栈顶。
3. 执行加法操作：弹出栈顶的两个数，计算它们的和，将结果推回栈顶。
4. 将和的结果存储到变量`c`。



#### 提问：**在方法执行时如何从局部变量表到操作数栈的数据传递过程。**

底层实现上，更准确地说是发生了数据的复制。



当然，JVM使用一套类型特定的指令来处理不同类型的数据。例如：

- 对于整型数据，使用`iload`指令从局部变量表加载到操作数栈。
- 对于浮点型数据，使用`fload`。
- 对于对象引用，使用`aload`。

#### 动态链接（Dynamic Linking）

每个栈帧内部包含一个指向运行时常量池中该栈帧所属方法的引用，以支持方法中的符号引用。这允许方法中的符号引用在运行期被转换为直接引用，这个过程称为动态链接：

- 动态链接是为了支持Java的多态性和方法重写，使得方法调用在运行时能绑定到正确的方法实现。

#### 方法出口（Return Address）

方法出口信息或称为调用终点信息，是当一个方法完成执行后，控制权需要返回到的代码位置。这部分信息包括调用该方法的位置的指令地址，这样一旦方法执行完成（正常完成或异常退出），虚拟机就能知道接下来执行哪里的代码。

**所以，总结一下，方法出口的关键是：保存调用该方法的调用者的位置。所以其实就是线程中栈帧的栈返回地址，返回上一个栈帧（调用该方法的调用者的栈帧）**

#### 补充：异常状态

在 Java 虚拟机规范中，对这个区域规定了两种异常状态：（关键在于是不是你栈本身的问题）

- 如果线程请求的栈深度大于虚拟机所允许的的深度，将抛出 **StackOverflowError** 异常。
- 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出 **OutOfMemoryError** 异常。



### 本地方法栈

其跟虚拟机栈相似，只不过一个保存的是字节码对应的Java方法，另一个则是专门支持Native方法，即那些通常用C或C++编写，并通过Java本地接口（JNI）调用的方法。抛出的异常和上面相同。



### JAVA堆

其实就是基于一片共享内存空间实现的。

但是为了方便分级进行内存回收，因此分为了新生代和老年代，新生代的经常被回收，回收 的效率高，老年代的很少被回收，回收效率低。新生代又分为eden区和survivor区，新创建的试在eden区，存活一段时间后被移动到survivor区。然后最后还能存活，就放到老年代。

同时，为了方便用户的无锁的快速分配，每个线程可以在堆中拥有自己的私有分配区域：TLAB，这样对象分配时可以在无锁的情况下进行，大大减少了线程之间的竞争。但它只是逻辑上的私有，物理上仍然是存储在共享的堆内存中。每个TLAB（Thread Local Allocation Buffer）在Eden空间内划分。



1. **新生代（Young Generation）**：

   - **Eden区**：新生成的对象首先在此区域分配内存。由于大多数对象生命周期短暂，Eden区通常很快被填满，随后进行一次Minor GC（也称为Young GC），清理那些已经死亡的对象。
   - **Survivor区**：这里有两个部分，From Survivor和To Survivor。在Minor GC发生后，从Eden区和一个Survivor区（From）存活下来的对象会被移动到另一个Survivor区（To）。在下一次GC前，From和To会交换角色。

2. **老年代（Old Generation）**：

   - 那些从新生代Survivor区存活下来并且已经经历了多次GC的对象会被晋升到老年代。老年代的空间更大，对象存活时间更长，GC发生的频率较低，通常使用标记-清除或标记-整理算法进行垃圾回收。

   

### 方法区

**方法区主要用于存储静态变量，解释后的机器语言代码，以及类信息、运行时常量池。**

这个前面的两个区域存放的静态变量和JIT解释的机器语言我可以理解，将他当作 c语言中的全局数据段和代码段即可。可是后面这个类信息和运行时常量池是什么？我不理解啊。



就是，现在.class文件被装载进来时，实际上是被经过解析，将他解析成JVM可以理解和管理的内部数据结构的格式：类信息，里面包括：如类名、超类名、接口、访问权限、字段、方法及它们的属性。然后存放在方法区中。

而运行时常量池里面存放的是类中声明的常量，以及对其它类的符号引用（这个符号引用存放的是符号？还是直接引用的地址？）

在运行时常量池中，符号引用最初被加载进来时，存储的是与源.class文件中相同的符号信息。随后，**当进行解析时，这些符号引用会被转换成直接引用，这些直接引用实际上是内存地址或者偏移量，它们指向方法区中或堆中的具体数据结构或对象。**



其实就是，你可以将方法区理解为c语言对应的代码段和数据段，被解释后的机器语言代码和被解析的类信息合起来可以视作代码段，静态变量和字面量是数据段，符号则是符号表。

#### 类信息

当Java类被加载到JVM时，JVM读取`.class`文件中的数据，并将其解析为在JVM内部使用的数据结构。这些信息包括：

- **类的全名**：包括包名和类名。
- **超类信息**：当前类继承的父类。
- **接口信息**：类实现的所有接口。
- **访问修饰符**：例如public, private, protected等。
- **字段信息**：类中声明的所有字段，包括名称、类型、修饰符等。
- **方法信息**：类中定义的所有方法，包括方法名称、返回类型、参数、修饰符以及方法的字节码。
- **其他元数据**：如注解、泛型类型等。

这些信息主要用于类型检查、访问控制、继承、多态等JVM的核心功能，同时也是动态链接（方法调用和变量访问解析）的基础。

#### 运行时常量池

每个类或接口在JVM中都有一个与之对应的运行时常量池，这是方法区的一部分。它包含几类不同的常量：

- **字面量**：如文本字符串、声明为final的常量值。
- 符号引用：
  - **类和接口的全名**：用于动态类型加载。
  - **字段的名称和描述符**：描述符用来表示字段的类型，如L表示引用类型。
  - **方法的名称和描述符**：描述符包括方法的参数类型和返回类型。

这些常量在类加载后被存入运行时常量池，供类及其实例使用。例如，当编译器遇到一个字符串字面量时，它会在运行时常量池中查找或创建一个表示这个字符串的条目。

当代码中引用其他类的字段或方法时，符号引用会在类被链接时解析成直接引用。

#### 举例说明

假设我们有一个Java类定义如下：

```
public class Example {
    public static final int CONSTANT = 10;
    public static int staticVar;

    public void method() {
        System.out.println("Method called");
    }
}
```

在这个类被加载到JVM时：

- 字段`CONSTANT`的值`10`将存储在运行时常量池中。

- 类`Example`的结构信息，包括其方法`method`的字节码，将存储在方法区的其他部分。

- 当`method`中的`System.out.println`被调用时，对`System`类和`out`字段的引用以及`println`方法的符号引用也将存储在运行时常量池中。





### 类加载过程（Class Loading）

#### 加载（Loading）

- **读取二进制数据**：JVM从.class文件中读取`Example`类的二进制数据。
- **创建类对象**：在方法区中为`Example`类创建一个类对象，用于存储类的结构信息，如常量池、字段数据、方法代码等。

#### 链接（Linking）

- **验证（Verification）**：检查载入的类或接口的正确性，确保它符合JVM规范，没有安全问题。
- **准备（Preparation）**：为类变量分配内存，并设置默认初始值。例如，`staticVar`分配内存并默认初始化为0。
- **解析（Resolution）**：将类、接口、字段和方法的符号引用转换成直接引用。例如，`System.out`和`println`方法的符号引用将被解析为具体地址。

#### 初始化（Initialization）

- **执行类构造器**：执行类构造器 `<clinit>` 方法，这可能包括静态代码块和类变量的赋值操作。对于`Example`类，如果有静态初始化块，则在此时执行。

### 2. 方法执行过程（Method Execution）

#### 方法调用

- 当`Example`类的`method()`被调用时，JVM为这个方法调用创建一个新的栈帧并推入当前线程的栈中。

#### 栈帧组成

- **局部变量表**：存储方法的参数（如果有）和方法内的局部变量。
- **操作数栈**：一个LIFO栈，用于存放方法执行过程中的操作数，例如计算数据和方法调用参数。

#### 执行方法

- **解析引用**：在`method()`中调用`System.out.println`时，JVM会解析`System`类的`out`字段和`println`方法的引用。
- **执行指令**：JVM执行`method()`方法中的字节码指令。这包括将`"Method called"`字符串常量推送到操作数栈上，然后调用`println`方法。
- **打印输出**：`println`方法从操作数栈中取得`"Method called"`字符串，执行打印操作。

### 3. 方法返回

- 当`method()`执行完毕，控制权返回调用者，相应的栈帧从虚拟机栈中弹出，释放相关资源。





是的，您的理解是正确的。在Java虚拟机中，对类的字段和方法的引用，如`System.out`字段和`println`方法，初次在代码中出现时是以符号引用的形式存在。符号引用一般包含类的全限定名、方法名和字段名等，它们是在编译期生成的，与类文件一起存储在运行时常量池中。这些符号引用在类的解析阶段会被转换为直接引用，即具体的内存地址或偏移量。下面是整个解析过程的详细步骤：

### 1. 符号引用

在Java代码编译后的类文件中，所有对其他类、接口、字段、方法的引用都以符号引用的形式存储。这些符号引用都保存在运行时常量池中，它们只是一些文本信息，如：

- 对于字段`System.out`，符号引用可能是：`java/lang/System.out:Ljava/io/PrintStream;`
- 对于方法`println(String)`，符号引用可能是：`java/io/PrintStream.println:(Ljava/lang/String;)V`

### 2. 解析过程

当Java虚拟机首次使用这些符号引用时，例如在`Example.method()`中第一次调用`System.out.println("Method called")`，JVM会进行解析操作，将符号引用转换为直接引用。这个过程主要包括：

- **查找类和接口**：首先定位符号引用所指向的类或接口，如`java.lang.System`和`java.io.PrintStream`。
- **解析字段和方法**：然后在定位到的类或接口中查找相应的字段和方法。如果这些类还未被加载和初始化，JVM会先加载并初始化它们。
- **获取内存地址**：字段或方法的解析结果是它们在内存中的具体地址或者对应的方法表中的索引位置。这个地址或索引就是直接引用。

### 3. 动态链接

这个解析过程是动态链接的一部分，允许Java程序在运行时按需加载和链接类。动态链接的好处是提高了程序的模块化，使得只有实际使用到的类和方法才被加载和初始化。

### 4. 使用直接引用

一旦字段和方法被解析为直接引用，JVM就可以通过这些直接引用高效地访问字段和调用方法。对于`System.out.println`的调用，一旦`System.out`的直接引用和`println`方法的直接引用被确定，JVM就可以直接通过这些引用来操作`PrintStream`的实例和调用`println`方法。








### 补充：堆和栈的区别

堆和栈都只是内存中的一块区域，为什么出现两个不同的区域，这是为了管理变量的生命周期。栈负责处理局部变量，堆负责处理生命周期超越局部的。 同时，栈区分配效率高于堆区，因为栈区只需要进行指针的移动即可。而堆区？需要进行遍历，找到可用的段，分配空间，处理剩余空间（形成新的段或合并）。其比栈区复杂很多。