[toc]

## 精简版

todo：这个要好好看看



## 内部类

### 内部类

内部类分为两类：非静态内部类（有时称为成员内部类）和静态内部类。

#### 非静态内部类

关键点：非静态内部类的对象隐式地关联到外部类的一个对象

- **访问权限**：非静态内部类可以无限制地访问外部类的成员，包括私有成员。这是因为非静态内部类的每个实例都自动持有对其外部类实例的引用。

- 实例化：由于非静态内部类的对象隐式地关联到外部类的一个对象，因此它们不能在外部类的静态上下文中直接实例化。要创建非静态内部类的实例，您首先需要一个外部类的实例。

  - 示例：

    ```
    public class Outer {
        class Inner {
            void display() {
                System.out.println("Inside Inner");
            }
        }
    }
    
    public class Test {
        public static void main(String[] args) {
            Outer outer = new Outer();
            Outer.Inner inner = outer.new Inner();
            inner.display();
        }
    }
    ```

#### 静态内部类

关键点：静态内部类可以被视为外部类的静态成员。

- **访问外部类成员**：静态内部类不能直接访问外部类的实例变量和方法；它们只能访问外部类的静态成员。静态内部类可以被视为外部类的静态成员。

- 实例化：静态内部类的对象可以不依赖于外部类的实例而被创建，且可以直接创建。

  - 示例：

    ```
    public class Outer {
        static class StaticInner {
            void display() {
                System.out.println("Inside Static Inner");
            }
        }
    }
    
    public class Test {
        public static void main(String[] args) {
            Outer.StaticInner staticInner = new Outer.StaticInner();
            staticInner.display();
        }
    }
    ```





### 匿名内部类（没搞懂）

匿名内部类适用于只需要一次使用的场景。

#### 原理

1. **编译时行为**：
   - 当编译包含匿名内部类的Java代码时，编译器会为每一个匿名内部类生成一个独立的类文件。这些类文件的命名通常是外部类的名称后跟一个美元符号`$`和一个数字，如`OuterClass$1.class`。
   - 这个独立的类实现了指定的接口或者扩展了某个类，并包含了重写的方法或新增的功能。
2. **作用域和生命周期**：
   - 匿名内部类只在定义它的作用域内可见，通常这个作用域是一个方法或一个代码块。
   - 它的生命周期也被限制在这个作用域内，匿名内部类的对象不能在其作用域外被引用。
3. **访问外部变量**：
   - 匿名内部类可以访问其外部类的成员（包括私有成员）。
   - 对于局部变量，如果匿名内部类需要访问它们，那么这些变量必须是`final`的或者实质上是`final`的（即它们在初始化之后不再改变）。这是因为Java在内部实际上是通过复制这些变量的值来实现访问的，确保值的不变性从而避免同步问题。

#### 目的和用途

1. **简化代码**：
   - 使用匿名内部类可以避免Java文件膨胀，因为不需要显式地定义一个完整的类。
   - 它使得代码更紧凑、更易读，因为实现细节紧靠着使用环境。
2. **方便事件处理和回调实现**：
   - 在图形用户界面（GUI）编程中，匿名内部类使得事件监听器的实现变得直接和简单。
   - 它也常用于其他需要回调的场景，如在线程运行、排序比较器等。
3. **即用即弃的实现**：
   - 对于只需要一次使用的接口实现或类扩展，匿名内部类提供了一种非常便捷的方式，而无需在代码库中增加额外的类。

#### 例子

假设你正在编写一个GUI应用，需要为一个按钮添加点击事件。使用匿名内部类可以直接在按钮初始化的地方处理点击事件，而不需要单独定义一个实现了`ActionListener`接口的类：

```
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Button clicked!");
    }
});
```

这种方法将事件处理器的逻辑保持在使用它的上下文附近，提高了代码的可读性和维护性。

总的来说，匿名内部类是Java中处理一些需要临时实现某个接口或类的方法的一种灵活而强大的工具。





我不是很理解：假设你正在编写一个GUI应用，需要为一个按钮添加点击事件。使用匿名内部类可以直接在按钮初始化的地方处理点击事件，而不需要单独定义一个实现了ActionListener接口的类：