[toc]

## 精简版

1. 对象存活判断：
   1. 引用计数：每个对象持有一个引用计数器，每当有一个地方引用它时，计数器值加1；引用失效时，计数器值减1。当引用计数为0时，对象可以被回收。但是无法解决循环引用的问题（A引用B，B引用A，但是没有第三者引用他们，他们实际上是不可达的。）
   2. 可达性分析：给予图论，，从一系列的根对象开始向下搜索，如果对任何根对象，都有：无法从根节点无法到达这个对象，则证明此对象是不可达的。这个根节点有：方法区中的类静态属性引用的对象
2. 垃圾收集算法：
   1. 标记清除算法：
      1. 原理：算法分为两个阶段，标记和清除。首先，垃圾收集器从根集合开始遍历，标记所有可达的对象。在标记阶段之后，收集器遍历堆，清除所有未被标记的对象。
      2. 缺点：
         1. 速度可能较慢，因为需要标记所有活动的对象然后清除所有非活动的对象。
         2. 会产生内存碎片。内存碎片会使得程序在未来分配大对象时可能因为找不到连续的空间而不得不触发更多的垃圾回收。
   2. 复制算法：
      1. 原理：将内存划分为两块，每次只用其中一块。当这一块内存用完时，程序就将活动的对象（也是通过标记确定对象是否活跃）复制到另一块内存中，并清理掉使用过的内存块。
      2. 缺点：内存使用效率低，只有一半可以用。同时：对生命周期长的对象，频繁复制会降低效率。
   3. 标记整理算法：
      1. 原理：结合了标记-清除和复制算法的优点。首先标记所有可达的对象，然后将所有存活的对象移向内存的一端，接着清理掉边界以外的内存。就是在标记清除算法的基础上添加了整理的逻辑
      2. 缺点：比较复杂，同时移动的过程中要更新对象的引用。
   4. 分代收集算法：
      1. 原理：把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

## 1.对象存活判断

### 引用计数

- **机制**：每个对象持有一个引用计数器，每当有一个地方引用它时，计数器值加1；引用失效时，计数器值减1。当引用计数为0时，对象可以被回收。
- **问题**：主要问题是无法解决循环引用的问题，因此Java主要采用可达性分析来判断对象的存活。

### 可达性分析

- **机制**：这种方法基于图论，从一系列的根对象（GC Roots）开始向下搜索，如果一个对象到根节点没有任何引用链相连（即从根节点无法到达这个对象），则证明此对象是不可达的。
- **GC Roots**：包括但不限于虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中的类静态属性引用的对象、方法区中常量引用的对象以及本地方法栈中JNI（即通常说的Native方法）引用的对象。





### 对象的引用

在Java中，对对象的引用通常是指指向内存中的对象的指针或句柄。当你在Java程序中创建一个对象时，实际上你在堆内存中创建了对象的实例，并通过引用来操作这个对象。引用存储的是对象在内存中的地址，或者通过某种方式间接指向该地址的信息。

#### 示例

```
Person person = new Person("John Doe");
```

在这个示例中，`person` 是一个引用，它指向 `Person` 类的一个新实例。这个引用存储了实例在内存中的地址，通过这个引用，你可以访问和修改对象的属性或调用对象的方法。





### 引用计数无法解决循环引用的问题

当两个或更多对象相互引用，但没有其他活动引用指向它们时，这些对象理论上是无用的，应该被回收，但由于它们互相持有对方的引用，它们的引用计数永远不会达到零。

示例说明

假设有两个类`A`和`B`，它们互相持有对方的引用：

```
class A {
    B b;
    void linkToB(B b) {
        this.b = b;
    }
}

class B {
    A a;
    void linkToA(A a) {
        this.a = a;
    }
}

public class Main {
    public static void main(String[] args) {
        A a = new A();
        B b = new B();

        a.linkToB(b);  // A对象持有B对象的引用
        b.linkToA(a);  // B对象持有A对象的引用

        a = null;  // 断开外部对A对象的引用
        b = null;  // 断开外部对B对象的引用
    }
}
```

在这个例子中：

- 对象`a`和对象`b`被创建并且互相引用。
- 外部对`a`和`b`的引用被设为`null`，意味着没有外部引用直接指向这两个对象。
- 然而，由于`a`和`b`互相持有对方的引用，它们的引用计数不会降至零。即使它们已经无法从程序的其他部分访问，它们也不会被引用计数的垃圾收集器回收。

此时：尽管`A`和`B`对象内部相互持有对方的引用，它们从程序的外部来看是不可达的，因为没有任何活跃的引用链从根集（如本地变量、静态字段等）指向这两个对象。这种情况下，对象`a`和`b`形成了一个封闭的循环引用，它们在逻辑上已经是不可达的，因为不存在从程序的活跃部分到这个循环的路径。





### 可达性分析（Reachability Analysis）

1. 可达性分析（Reachability Analysis）的核心思想是，如果一个对象可以从任何一个GC Roots开始通过一系列的引用链被访问到，那么这个对象是存活的；否则，对象不可达，可以被视为垃圾收集的候选。

   ### 引用链和GC Roots

   引用链是指从GC Roots开始，每个节点通过字段引用到其他对象的链条。如果至少存在一条这样的链条可以连到某个对象，这个对象就是可达的。

   GC Roots主要包括：

   - 局部变量：所有的本地变量都是GC Roots，这些变量在Java方法的栈帧中，即虚拟机栈中。
   - 活跃的线程：活动线程也是GC Roots，因为它们持有对栈帧中局部变量和参数的引用。
   - 静态字段：由类的定义持有的字段，因为它们属于Java类，而Java类由类加载器加载，存活在方法区中。
   - JNI引用：由本地代码创建并通过JNI接口到Java对象的引用。

   ### 详细的例子解释可达性分析

   假设我们有如下的对象和引用结构，用以解释可达性分析的过程：

   ```
   public class Main {
       private static Main s; // 静态变量，GC Root
       private Main other;    // 实例变量
   
       public static void main(String[] args) {
           Main a = new Main();  // 局部变量，GC Root
           Main b = new Main();  // 局部变量，GC Root
           Main c = new Main();  // 局部变量，GC Root
   
           a.other = b;  // a 引用 b
           b.other = c;  // b 引用 c
           c.other = a;  // c 引用 a 形成一个环
   
           s = a;        // 将 a 保存为静态变量
   
           b = null;     // 断开 b 的引用
           c = null;     // 断开 c 的引用
   
           // 触发垃圾收集
           System.gc();
       }
   }
   ```

   在这个例子中：

   - 对象 `a`、`b`、`c` 在 `main` 方法中创建，并且它们相互引用形成一个环状结构。
   - `a` 被一个静态变量 `s` 引用，并且 `a` 作为局部变量直接位于GC Roots。
   - 当局部变量 `b` 和 `c` 被设置为 `null`，直接从GC Roots到 `b` 和 `c` 的引用路径消失。但由于 `a` 通过静态变量 `s` 依然可达，因此整个环（`a`、`b`、`c`）都仍然可达。

   #### 可达性分析的结果

   - 即使 `b` 和 `c` 的直接引用被删除，它们仍然可以通过 `a` 间接访问。
   - 由于整个环形结构可以通过GC Roots（在这个案例中是静态变量 `s` 和局部变量 `a`）访问到，因此 `a`、`b` 和 `c` 在垃圾收集发生时不会被回收。

   这个例子说明了即使存在复杂的引用环，只要从GC Roots到任意一个对象存在至少一条路径，那么这个对象及其关联的对象都不会被判定为垃圾。



### 补充：这里的b = null是什么意思？意思是：b这个局部变量被清除掉了？

在Java中，当你将一个变量（如 `b`）赋值为 `null`，这意味着你在断开这个变量与它原先指向的对象之间的引用关系。此操作并不是清除 `b` 这个局部变量本身，而是让 `b` 不再指向任何对象。



### 示例解释

考虑如下简化的例子：

```java
Main b = new Main();  // b 指向一个新创建的 Main 对象
b = null;            // 断开 b 和 Main 对象之间的引用
```

在这个例子中：

- **第一行**，`b` 被初始化，指向一个新创建的 `Main` 类的实例。这时，堆内存中存在一个 `Main` 对象，而变量 `b` 存储了指向这个对象的引用。
- **第二行**，将 `b` 赋值为 `null` 后，`b` 不再指向之前创建的 `Main` 对象。如果没有其他引用指向这个 `Main` 对象，那么该对象变成了无法通过任何引用访问的状态，因此成为了垃圾收集的候选对象。



我懂了，Main b = new Main()，分为两步，第一步是在堆上创建一个Main对象，第二步是将b进行解析，链接到这个对象上。将其置为null，表示断开链接，而Main对象此时还并未死亡，直到被判定为不存活，进行垃圾回收





## 2. 垃圾收集算法

### 1. 标记-清除算法 (Mark-Sweep)

**原理**：此算法分为两个阶段，标记和清除。首先，垃圾收集器从根集合开始遍历，标记所有可达的对象。在标记阶段之后，收集器遍历堆，清除所有未被标记的对象。

**优点**：

- 简单直接。
- 不需要额外的空间来进行垃圾回收。

**缺点**：

- 速度可能较慢，因为需要标记所有活动的对象然后清除所有非活动的对象。
- 会产生内存碎片。内存碎片会使得程序在未来分配大对象时可能因为找不到连续的空间而不得不触发更多的垃圾回收。

### 2. 复制算法 (Copying)

**原理**：将内存划分为两块，每次只用其中一块。当这一块内存用完时，程序就将活动的对象（也是通过标记确定对象是否活跃）复制到另一块内存中，并清理掉使用过的内存块。

**优点**：

- 实现简单，回收效率高。
- 解决了内存碎片的问题。

**缺点**：

- 只能使用堆内存的一半，降低了内存的使用效率。
- 对于生命周期较长的对象，频繁复制会降低效率。

### 3. 标记-整理算法 (Mark-Compact)

**原理**：结合了标记-清除和复制算法的优点。首先标记所有可达的对象，然后将所有存活的对象移向内存的一端，接着清理掉边界以外的内存。

**优点**：

- 避免了内存碎片的产生。
- 不需要额外的空间，与复制算法相比，可以利用全部的堆空间。

**缺点**：

- 比复制算法更复杂，移动对象需要更新所有指向这些对象的引用，可能会有更高的开销。



尽管复制算法和标记-整理算法都涉及到“标记”活动对象，但它们的关键区别在于：

- **复制算法**：活动对象被复制到一个新的、干净的内存区域，原区域被完全清空。
- **标记-整理算法**：活动对象在同一内存区域内被移动，以减少碎片，清理未使用的内存。

同时，标记整理是在标记清除的基础上添加了一个整理的步骤，整理过程保证了所有存活对象都紧密地排列在一起，之后的空闲内存都是连续的一块区域，因此解决了内存碎片的问题。



### 4. 分代收集算法 (Generational Collection)

“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。





## 3.垃圾收集器

### Serial收集器

- 单线程的垃圾收集器，适用于单核处理器环境。
- **新生代**使用复制算法，**老年代**使用标记-整理算法。

### Parallel收集器

（又称为吞吐量优先收集器）：

- 多线程的垃圾收集器，适用于多核处理器环境。
- **新生代**使用复制算法，**老年代**使用标记-整理算法。



### CMS (Concurrent Mark Sweep) 收集器

#### 目标和特点：

- **目标**：最小化应用的停顿时间，适用于对响应时间敏感的应用，如Web服务器和其他需要快速响应的服务端应用。
- **特点**：基于“标记-清除”算法，通过并发标记和清除来减少停顿时间，虽然不消除停顿，但大幅减少停顿时间。

#### 工作过程：

1. **初始标记（Initial Mark）**：
   - **STW（Stop-The-World）短暂停顿**：快速标记从GC Roots直接可达的对象。
   - 时间较短，因为只标记了与GC Roots直接相关的对象。
2. **并发标记（Concurrent Marking）**：
   - 遍历对象图，从GC Roots开始标记所有可达的对象。
   - **与应用线程并发执行**，减少对应用的影响。
3. **重新标记（Remark）**：
   - **STW短暂停顿**：修正在并发标记期间，由于应用程序运行导致的新引用关系的变化。
   - 确保标记阶段的完整性和准确性。
4. **并发清除（Concurrent Sweep）**：
   - 清理未被标记的对象。
   - **与应用线程并发执行**，减少停顿时间。

#### 优点：

- **最小化停顿时间**：适合对响应时间要求高的应用。
- **并发性高**：大部分标记和清除工作与应用线程并发执行。

#### 缺点：

- **内存碎片**：标记-清除算法可能会产生内存碎片，导致内存利用率下降。
- **并发模式失败（Concurrent Mode Failure）**：在老年代内存不足时，会触发Full GC，导致较长时间的停顿。

### G1 (Garbage-First) 收集器

#### 目标和特点：

- **目标**：提供更可预测的停顿时间模型，适用于大内存应用。
- **特点**：基于标记-整理算法，通过划分多个内存区域（Region）来管理整个Java堆，尽量避免内存碎片。

#### 工作过程：

1. **初始标记（Initial Mark）**：
   - **STW短暂停顿**：标记从GC Roots直接可达的对象。
   - 与年轻代垃圾收集（Young GC）结合，时间短。
2. **并发标记（Concurrent Marking）**：
   - 遍历对象图，标记所有可达的对象。
   - **与应用线程并发执行**，减少停顿时间。
3. **最终标记（Final Mark）**：
   - **STW短暂停顿**：处理并发标记阶段遗漏的少量引用变化。
   - 确保所有在并发标记期间新创建的对象和新建立的引用关系被正确标记。
4. **筛选回收（Live Data Counting and Cleanup）**：
   - 评估每个区域的存活对象和垃圾比例，根据回收优先级回收最有价值的区域。
   - **标记-整理**：将存活对象整理到一起，回收整个区域，减少内存碎片。

#### 优点：

- **更可预测的停顿时间**：通过对堆的区域化管理，提供更好的停顿时间控制。
- **减少内存碎片**：通过整理空闲空间，有效减少内存碎片，适用于大堆内存。

### 比较CMS和G1：

- **停顿时间控制**：CMS主要减少停顿时间，但在高负载或内存碎片严重时可能不稳定。G1提供更可预测的停顿时间，适合需要稳定响应时间的应用。
- **内存管理**：CMS可能导致内存碎片，影响内存利用率。G1通过标记-整理机制有效管理内存碎片，提高内存利用率。



### 标记从GC Roots直接可达的对象。和遍历对象图，从GC Roots开始标记所有可达的对象。 两者有什么区别吗？

关键在于直接引用和间接引用。

假设有如下对象引用关系：

- GC Roots引用对象A
- 对象A引用对象B和对象C
- 对象B引用对象D

在**初始标记阶段**：

- 标记对象A，因为它是直接由GC Roots引用的对象。

在**并发标记阶段**：

- 从对象A开始，标记对象B和对象C（因为它们被A引用）。
- 然后，继续从对象B出发，标记对象D（因为它被B引用）。
- 最终，A、B、C、D都被标记。



### ok，现在考量一下CMS，假如其GC Roots是A，A直接引用B，B间接引用C。初始标记阶段，A可达B。并发标记阶段，B不可达C。重新标记阶段，A可达B，但是这个阶段，B突然可达C，此时进行并发清除时，C就要被错误的清除掉。

### 具体机制：增量更新（Incremental Update）

在并发标记阶段，CMS收集器采用增量更新的机制来处理引用关系的动态变化。增量更新的过程如下：

- **增量更新**：当对象B在并发标记阶段发生了引用关系的变化（例如，从不可达变为可达），CMS会记录这些变化。在重新标记阶段，CMS会重新扫描并更新这些变化，确保所有新增的可达对象都被正确标记。

## 4.内存模型和回收策略

![img](https://camo.githubusercontent.com/ee801f1facbe41be0b4c871a7a64df524f6863a0faf104892c06213884c3d420/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f706e672f71647a5a42453733685773626866416e67396962716663626a72716779525771414b69614a32553735534759775168733274754e62587475384b4970615573424f6148524b58663765737575466f4d6a454c467869624956672f3634303f77785f666d743d706e672674703d7765627026777866726f6d3d352677785f6c617a793d312677785f636f3d31)

### Java 堆内存结构

#### 1. 新生代 (Young Generation)

新生代是大多数Java对象诞生并初步存活的地方。新生代主要由三个部分组成：

- **Eden区**：大部分新创建的对象首先在Eden区分配。Eden区通常较大，因为这里频繁地创建和销毁对象。
- **Survivor区**：包括两个部分，From和To。这两个区域的角色会在每次垃圾回收后互换。对象从Eden区存活下来后，首先被移动到From区，随后在连续几次垃圾回收过程中，在From和To区之间移动。只有经常存活的对象最终会被移动到老年代。

#### 2. 老年代 (Old Generation)

老年代用于存放长时间存活的对象。一般来说，这些对象已经经历了多次新生代的垃圾回收，仍然存活的对象会被晋升到老年代中。老年代的大小和生命周期管理是性能调优的重要方面，因为老年代满了会触发Major GC，这通常比Minor GC更耗时。

### 垃圾回收策略

#### Minor GC

- **触发时机**：当Eden区满了时触发。
- **过程**：回收Eden和一个Survivor区（From），将存活的对象移动到另一个Survivor区（To）或直接晋升到老年代。
- **特点**：只涉及新生代，速度较快，频繁发生。

#### Major GC / Full GC

- **触发时机**：老年代满了或其他情况（如System.gc()调用）时触发。
- **过程**：涉及整个堆（包括新生代和老年代），使用标记-清除或标记-整理算法。
- **特点**：STW时间较长，影响性能，尽量避免频繁发生。